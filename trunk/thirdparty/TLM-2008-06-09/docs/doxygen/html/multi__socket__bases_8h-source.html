<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TLM 2: C:/ESLX/projects/TLMWG/tlm2/include/tlm/tlm_utils/multi_socket_bases.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>C:/ESLX/projects/TLMWG/tlm2/include/tlm/tlm_utils/multi_socket_bases.h</h1><a href="multi__socket__bases_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  The following code is derived, directly or indirectly, from the SystemC</span>
<a name="l00004"></a>00004 <span class="comment">  source code Copyright (c) 1996-2008 by all Contributors.</span>
<a name="l00005"></a>00005 <span class="comment">  All Rights reserved.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">  The contents of this file are subject to the restrictions and limitations</span>
<a name="l00008"></a>00008 <span class="comment">  set forth in the SystemC Open Source License Version 3.0 (the "License");</span>
<a name="l00009"></a>00009 <span class="comment">  You may not use this file except in compliance with such restrictions and</span>
<a name="l00010"></a>00010 <span class="comment">  limitations. You may obtain instructions on how to receive a copy of the</span>
<a name="l00011"></a>00011 <span class="comment">  License at http://www.systemc.org/. Software distributed by Contributors</span>
<a name="l00012"></a>00012 <span class="comment">  under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF</span>
<a name="l00013"></a>00013 <span class="comment">  ANY KIND, either express or implied. See the License for the specific</span>
<a name="l00014"></a>00014 <span class="comment">  language governing rights and limitations under the License.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment"> *****************************************************************************/</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="preprocessor">#ifndef __MULTI_SOCKET_BASES_H__</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span><span class="preprocessor">#define __MULTI_SOCKET_BASES_H__</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;systemc&gt;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#if !(SYSTEMC_VERSION &lt;= 20050714)</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor"># include "sysc/kernel/sc_boost.h"</span>
<a name="l00025"></a>00025 <span class="preprocessor"># include "sysc/kernel/sc_spawn.h"</span>
<a name="l00026"></a>00026 <span class="preprocessor"># include "sysc/kernel/sc_spawn_options.h"</span>
<a name="l00027"></a>00027 <span class="preprocessor">#endif</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="tlm_8h.html">tlm.h</a>"</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#include "boost/function.hpp"</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include "boost/mem_fn.hpp"</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="keyword">namespace </span>tlm_utils {
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="comment">/*</span>
<a name="l00038"></a>00038 <span class="comment">This class implements the fw interface.</span>
<a name="l00039"></a>00039 <span class="comment">It allows to register a callback for each of the fw interface methods.</span>
<a name="l00040"></a>00040 <span class="comment">The callbacks simply forward the fw interface call, but add the id (an int)</span>
<a name="l00041"></a>00041 <span class="comment">of the callback binder to the signature of the call.</span>
<a name="l00042"></a>00042 <span class="comment">*/</span>
<a name="l00043"></a>00043 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPES&gt;
<a name="l00044"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html">00044</a> <span class="keyword">class </span><a class="code" href="classtlm__utils_1_1callback__binder__fw.html">callback_binder_fw</a>: <span class="keyword">public</span> tlm::tlm_fw_transport_if&lt;TYPES&gt;{
<a name="l00045"></a>00045   <span class="keyword">public</span>:
<a name="l00046"></a>00046     <span class="comment">//typedefs according to the used TYPES class</span>
<a name="l00047"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#2ffd5af7b887450c7db7a5cc88ce5527">00047</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> TYPES::tlm_payload_type              <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#2ffd5af7b887450c7db7a5cc88ce5527">transaction_type</a>;
<a name="l00048"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#a522794b3b564136592bebcd756264b4">00048</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> TYPES::tlm_phase_type                <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#a522794b3b564136592bebcd756264b4">phase_type</a>;  
<a name="l00049"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#ee6780e841d3f314b0d7f21e6b705832">00049</a>     <span class="keyword">typedef</span> <a class="code" href="namespacetlm.html#dac10369502c45362dded44267fea971">tlm::tlm_sync_enum</a>                            <a class="code" href="namespacetlm.html#dac10369502c45362dded44267fea971">sync_enum_type</a>;
<a name="l00050"></a>00050   
<a name="l00051"></a>00051     <span class="comment">//typedefs for the callbacks</span>
<a name="l00052"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9d71a82a49f012f72d8709a098d2fdd3">00052</a>     <span class="keyword">typedef</span> boost::function&lt;sync_enum_type (int i, transaction_type&amp; txn, phase_type&amp; ph, sc_core::sc_time&amp; t)&gt; <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9d71a82a49f012f72d8709a098d2fdd3">nb_func_type</a>;
<a name="l00053"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#3fe33873cd124ac7860cc3be4a1b5fd2">00053</a>     <span class="keyword">typedef</span> boost::function&lt;void (int i, transaction_type&amp; txn, sc_core::sc_time&amp; t)&gt; <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#3fe33873cd124ac7860cc3be4a1b5fd2">b_func_type</a>;
<a name="l00054"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#42ebebb5a97a3b6fffe45d1ee6e37316">00054</a>     <span class="keyword">typedef</span> boost::function&lt;unsigned int (int i, transaction_type&amp; txn)&gt; <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#42ebebb5a97a3b6fffe45d1ee6e37316">debug_func_type</a>;
<a name="l00055"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f69d612d38a5e369a90007ce3fc27f50">00055</a>     <span class="keyword">typedef</span> boost::function&lt;bool (int i, transaction_type&amp; txn, tlm::tlm_dmi&amp; dmi)&gt; <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f69d612d38a5e369a90007ce3fc27f50">dmi_func_type</a>;
<a name="l00056"></a>00056 
<a name="l00057"></a>00057     <span class="comment">//ctor: an ID is needed to create a callback binder</span>
<a name="l00058"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#b8383f7f17eef92678045232c9231839">00058</a>     <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#b8383f7f17eef92678045232c9231839">callback_binder_fw</a>(<span class="keywordtype">int</span> <span class="keywordtype">id</span>): <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f12210d59dac8009fd180fd2d2d19411">m_id</a>(id){
<a name="l00059"></a>00059     }
<a name="l00060"></a>00060 
<a name="l00061"></a>00061     <span class="comment">//the nb_transport method of the fw interface</span>
<a name="l00062"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#ca4d674fd5a32bfb688d4d6b9054645d">00062</a>     <a class="code" href="namespacetlm.html#dac10369502c45362dded44267fea971">sync_enum_type</a> <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#ca4d674fd5a32bfb688d4d6b9054645d">nb_transport_fw</a>(<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#2ffd5af7b887450c7db7a5cc88ce5527">transaction_type</a>&amp; txn,
<a name="l00063"></a>00063                                 <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#a522794b3b564136592bebcd756264b4">phase_type</a>&amp; p,
<a name="l00064"></a>00064                                 sc_core::sc_time&amp; t){
<a name="l00065"></a>00065       <span class="comment">//check if a callback is registered</span>
<a name="l00066"></a>00066       <span class="keywordflow">if</span> (<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#2912485f6d8962d978491a7156c9fcd8">m_nb_f</a>-&gt;empty()){
<a name="l00067"></a>00067         std::cerr&lt;&lt;<span class="stringliteral">"No function registered"</span>&lt;&lt;std::endl;
<a name="l00068"></a>00068         exit(1);
<a name="l00069"></a>00069       }
<a name="l00070"></a>00070       <span class="keywordflow">else</span>
<a name="l00071"></a>00071         <span class="keywordflow">return</span> (*<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#2912485f6d8962d978491a7156c9fcd8">m_nb_f</a>)(<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f12210d59dac8009fd180fd2d2d19411">m_id</a>, txn, p, t); <span class="comment">//do the callback</span>
<a name="l00072"></a>00072     }
<a name="l00073"></a>00073     
<a name="l00074"></a>00074     <span class="comment">//the b_transport method of the fw interface</span>
<a name="l00075"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#8d570f0310e4183f680ed86bbb2270c8">00075</a>     <span class="keywordtype">void</span> <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#8d570f0310e4183f680ed86bbb2270c8">b_transport</a>(<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#2ffd5af7b887450c7db7a5cc88ce5527">transaction_type</a>&amp; trans,sc_core::sc_time&amp; t){
<a name="l00076"></a>00076       <span class="comment">//check if a callback is registered</span>
<a name="l00077"></a>00077       <span class="keywordflow">if</span> (<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9dbce3ae600107c26455c7cc0a1a521c">m_b_f</a>-&gt;empty()){
<a name="l00078"></a>00078         std::cerr&lt;&lt;<span class="stringliteral">"No function registered"</span>&lt;&lt;std::endl;
<a name="l00079"></a>00079         exit(1);
<a name="l00080"></a>00080       }
<a name="l00081"></a>00081       <span class="keywordflow">else</span>
<a name="l00082"></a>00082         (*<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9dbce3ae600107c26455c7cc0a1a521c">m_b_f</a>)(<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f12210d59dac8009fd180fd2d2d19411">m_id</a>, trans,t); <span class="comment">//do the callback</span>
<a name="l00083"></a>00083     }
<a name="l00084"></a>00084     
<a name="l00085"></a>00085     <span class="comment">//the DMI method of the fw interface</span>
<a name="l00086"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9c9c5f08913425426482827eed06c21f">00086</a>     <span class="keywordtype">bool</span> <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9c9c5f08913425426482827eed06c21f">get_direct_mem_ptr</a>(<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#2ffd5af7b887450c7db7a5cc88ce5527">transaction_type</a>&amp; trans, <a class="code" href="classtlm_1_1tlm__dmi.html">tlm::tlm_dmi</a>&amp;  dmi_data){
<a name="l00087"></a>00087       <span class="comment">//check if a callback is registered</span>
<a name="l00088"></a>00088       <span class="keywordflow">if</span> (<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#408ac3c4c7f6515530e8e81f3e2ca7a9">m_dmi_f</a>-&gt;empty()){
<a name="l00089"></a>00089         std::cerr&lt;&lt;<span class="stringliteral">"No function registered"</span>&lt;&lt;std::endl; 
<a name="l00090"></a>00090         exit(1);
<a name="l00091"></a>00091       }
<a name="l00092"></a>00092       <span class="keywordflow">else</span>
<a name="l00093"></a>00093         <span class="keywordflow">return</span> (*<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#408ac3c4c7f6515530e8e81f3e2ca7a9">m_dmi_f</a>)(<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f12210d59dac8009fd180fd2d2d19411">m_id</a>, trans,dmi_data); <span class="comment">//do the callback</span>
<a name="l00094"></a>00094     }
<a name="l00095"></a>00095     
<a name="l00096"></a>00096     <span class="comment">//the debug method of the fw interface</span>
<a name="l00097"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#dae94867ee608a2d90c378923b91fc0d">00097</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#dae94867ee608a2d90c378923b91fc0d">transport_dbg</a>(<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#2ffd5af7b887450c7db7a5cc88ce5527">transaction_type</a>&amp; trans){
<a name="l00098"></a>00098       <span class="comment">//check if a callback is registered</span>
<a name="l00099"></a>00099       <span class="keywordflow">if</span> (<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#6d99fd747d8c4acb61f4cc6773e7082a">m_dbg_f</a>-&gt;empty()){
<a name="l00100"></a>00100         std::cerr&lt;&lt;<span class="stringliteral">"No function registered"</span>&lt;&lt;std::endl; 
<a name="l00101"></a>00101         exit(1);
<a name="l00102"></a>00102       }
<a name="l00103"></a>00103       <span class="keywordflow">else</span>
<a name="l00104"></a>00104         <span class="keywordflow">return</span> (*<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#6d99fd747d8c4acb61f4cc6773e7082a">m_dbg_f</a>)(<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f12210d59dac8009fd180fd2d2d19411">m_id</a>, trans); <span class="comment">//do the callback</span>
<a name="l00105"></a>00105     }
<a name="l00106"></a>00106     
<a name="l00107"></a>00107     <span class="comment">//the SystemC standard callback register_port:</span>
<a name="l00108"></a>00108     <span class="comment">// - called when a port if bound to the interface</span>
<a name="l00109"></a>00109     <span class="comment">// - allowd to find out who is bound to that callback binder</span>
<a name="l00110"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#5b1c42bed01fe32b485392914ead91e2">00110</a>     <span class="keywordtype">void</span> <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#5b1c42bed01fe32b485392914ead91e2">register_port</a>(sc_core::sc_port_base&amp; b, <span class="keyword">const</span> <span class="keywordtype">char</span>* name){
<a name="l00111"></a>00111       <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#952c30578a74f82fc4d73609743bf371">m_caller_port</a>=&amp;b;
<a name="l00112"></a>00112     }
<a name="l00113"></a>00113     
<a name="l00114"></a>00114     <span class="comment">//register callbacks for all fw interface methods at once</span>
<a name="l00115"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f860cbda7b94fb0c8f687530f4c9bf2f">00115</a>     <span class="keywordtype">void</span> <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f860cbda7b94fb0c8f687530f4c9bf2f">set_callbacks</a>(<a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9d71a82a49f012f72d8709a098d2fdd3">nb_func_type</a>&amp; cb1, <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#3fe33873cd124ac7860cc3be4a1b5fd2">b_func_type</a>&amp; cb2, <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f69d612d38a5e369a90007ce3fc27f50">dmi_func_type</a>&amp; cb3, <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#42ebebb5a97a3b6fffe45d1ee6e37316">debug_func_type</a>&amp; cb4){
<a name="l00116"></a>00116       <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#2912485f6d8962d978491a7156c9fcd8">m_nb_f</a>=&amp;cb1;
<a name="l00117"></a>00117       <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9dbce3ae600107c26455c7cc0a1a521c">m_b_f</a>=&amp;cb2;
<a name="l00118"></a>00118       <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#408ac3c4c7f6515530e8e81f3e2ca7a9">m_dmi_f</a>=&amp;cb3;
<a name="l00119"></a>00119       <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#6d99fd747d8c4acb61f4cc6773e7082a">m_dbg_f</a>=&amp;cb4;
<a name="l00120"></a>00120     }
<a name="l00121"></a>00121     
<a name="l00122"></a>00122     <span class="comment">//getter method to get the port that is bound to that callback binder</span>
<a name="l00123"></a>00123     <span class="comment">// NOTE: this will only return a valid value at end of elaboration</span>
<a name="l00124"></a>00124     <span class="comment">//  (but not before end of elaboration!)</span>
<a name="l00125"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9ae1cab032dc01e99df4f18e39181859">00125</a>     sc_core::sc_port_base* <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9ae1cab032dc01e99df4f18e39181859">get_other_side</a>(){<span class="keywordflow">return</span> <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#952c30578a74f82fc4d73609743bf371">m_caller_port</a>;}
<a name="l00126"></a>00126     
<a name="l00127"></a>00127   <span class="keyword">private</span>:
<a name="l00128"></a>00128     <span class="comment">//the ID of the callback binder</span>
<a name="l00129"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f12210d59dac8009fd180fd2d2d19411">00129</a>     <span class="keywordtype">int</span> <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f12210d59dac8009fd180fd2d2d19411">m_id</a>; 
<a name="l00130"></a>00130     
<a name="l00131"></a>00131     <span class="comment">//the callbacks</span>
<a name="l00132"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#2912485f6d8962d978491a7156c9fcd8">00132</a>     <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9d71a82a49f012f72d8709a098d2fdd3">nb_func_type</a>* <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#2912485f6d8962d978491a7156c9fcd8">m_nb_f</a>; 
<a name="l00133"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9dbce3ae600107c26455c7cc0a1a521c">00133</a>     <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#3fe33873cd124ac7860cc3be4a1b5fd2">b_func_type</a>*  <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#9dbce3ae600107c26455c7cc0a1a521c">m_b_f</a>;
<a name="l00134"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#6d99fd747d8c4acb61f4cc6773e7082a">00134</a>     <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#42ebebb5a97a3b6fffe45d1ee6e37316">debug_func_type</a>* <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#6d99fd747d8c4acb61f4cc6773e7082a">m_dbg_f</a>;
<a name="l00135"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#408ac3c4c7f6515530e8e81f3e2ca7a9">00135</a>     <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#f69d612d38a5e369a90007ce3fc27f50">dmi_func_type</a>* <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#408ac3c4c7f6515530e8e81f3e2ca7a9">m_dmi_f</a>;
<a name="l00136"></a>00136     
<a name="l00137"></a>00137     <span class="comment">//the port bound to that callback binder</span>
<a name="l00138"></a><a class="code" href="classtlm__utils_1_1callback__binder__fw.html#952c30578a74f82fc4d73609743bf371">00138</a>     sc_core::sc_port_base* <a class="code" href="classtlm__utils_1_1callback__binder__fw.html#952c30578a74f82fc4d73609743bf371">m_caller_port</a>;   
<a name="l00139"></a>00139 };
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="comment">/*</span>
<a name="l00142"></a>00142 <span class="comment">This class implements the bw interface.</span>
<a name="l00143"></a>00143 <span class="comment">It allows to register a callback for each of the bw interface methods.</span>
<a name="l00144"></a>00144 <span class="comment">The callbacks simply forward the bw interface call, but add the id (an int)</span>
<a name="l00145"></a>00145 <span class="comment">of the callback binder to the signature of the call.</span>
<a name="l00146"></a>00146 <span class="comment">*/</span>
<a name="l00147"></a>00147 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPES&gt;
<a name="l00148"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html">00148</a> <span class="keyword">class </span><a class="code" href="classtlm__utils_1_1callback__binder__bw.html">callback_binder_bw</a>: <span class="keyword">public</span> tlm::tlm_bw_transport_if&lt;TYPES&gt;{
<a name="l00149"></a>00149   <span class="keyword">public</span>:
<a name="l00150"></a>00150     <span class="comment">//typedefs according to the used TYPES class</span>
<a name="l00151"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html#e9b0670df173b3803ea26d8b92191c66">00151</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> TYPES::tlm_payload_type              <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#e9b0670df173b3803ea26d8b92191c66">transaction_type</a>;
<a name="l00152"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html#2de2d9d75fa6b7a05a919c66a58ab497">00152</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> TYPES::tlm_phase_type                <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#2de2d9d75fa6b7a05a919c66a58ab497">phase_type</a>;  
<a name="l00153"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html#42c17ed2c79207e89d63b28b89358524">00153</a>     <span class="keyword">typedef</span> <a class="code" href="namespacetlm.html#dac10369502c45362dded44267fea971">tlm::tlm_sync_enum</a>                            <a class="code" href="namespacetlm.html#dac10369502c45362dded44267fea971">sync_enum_type</a>;
<a name="l00154"></a>00154   
<a name="l00155"></a>00155     <span class="comment">//typedefs for the callbacks</span>
<a name="l00156"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html#bc32b114c0888ce732337c0b13891a03">00156</a>     <span class="keyword">typedef</span> boost::function&lt;sync_enum_type (int i, transaction_type&amp; txn, phase_type&amp; p, sc_core::sc_time&amp; t)&gt; <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#bc32b114c0888ce732337c0b13891a03">nb_func_type</a>;
<a name="l00157"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html#8ce83c8584959c55a0a0319cdd27c59a">00157</a>     <span class="keyword">typedef</span> boost::function&lt;void (int i, sc_dt::uint64 l, sc_dt::uint64 u)&gt; <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#8ce83c8584959c55a0a0319cdd27c59a">dmi_func_type</a>;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159     <span class="comment">//ctor: an ID is needed to create a callback binder</span>
<a name="l00160"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html#fad88ed9bb20ec4e0bff9d1c4eb402f3">00160</a>     <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#fad88ed9bb20ec4e0bff9d1c4eb402f3">callback_binder_bw</a>(<span class="keywordtype">int</span> <span class="keywordtype">id</span>): <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#56f4eb80810779f77d6f9b76628b2427">m_id</a>(id){
<a name="l00161"></a>00161     }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     <span class="comment">//the nb_transport method of the bw interface</span>
<a name="l00164"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html#30ae951c74bcc1672dfa2749e1bec486">00164</a>     <a class="code" href="namespacetlm.html#dac10369502c45362dded44267fea971">sync_enum_type</a> <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#30ae951c74bcc1672dfa2749e1bec486">nb_transport_bw</a>(<a class="code" href="classtlm__utils_1_1callback__binder__bw.html#e9b0670df173b3803ea26d8b92191c66">transaction_type</a>&amp; txn,
<a name="l00165"></a>00165                                 <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#2de2d9d75fa6b7a05a919c66a58ab497">phase_type</a>&amp; p,
<a name="l00166"></a>00166                                 sc_core::sc_time&amp; t){
<a name="l00167"></a>00167       <span class="comment">//check if a callback is registered</span>
<a name="l00168"></a>00168       <span class="keywordflow">if</span> (<a class="code" href="classtlm__utils_1_1callback__binder__bw.html#6d967ce1ec96eed4a6133b0000279777">m_nb_f</a>-&gt;empty()){
<a name="l00169"></a>00169         std::cerr&lt;&lt;<span class="stringliteral">"No function registered"</span>&lt;&lt;std::endl; <span class="comment">//here we could do an automatic nb-&gt;b conversion</span>
<a name="l00170"></a>00170         exit(1);
<a name="l00171"></a>00171       }
<a name="l00172"></a>00172       <span class="keywordflow">else</span>
<a name="l00173"></a>00173         <span class="keywordflow">return</span> (*<a class="code" href="classtlm__utils_1_1callback__binder__bw.html#6d967ce1ec96eed4a6133b0000279777">m_nb_f</a>)(<a class="code" href="classtlm__utils_1_1callback__binder__bw.html#56f4eb80810779f77d6f9b76628b2427">m_id</a>, txn, p, t); <span class="comment">//do the callback</span>
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175     
<a name="l00176"></a>00176     <span class="comment">//the DMI method of the bw interface</span>
<a name="l00177"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html#d33af4e1236b00d58a36456d10c2ac38">00177</a>     <span class="keywordtype">void</span> <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#d33af4e1236b00d58a36456d10c2ac38">invalidate_direct_mem_ptr</a>(sc_dt::uint64 l, sc_dt::uint64 u){
<a name="l00178"></a>00178       <span class="comment">//check if a callback is registered</span>
<a name="l00179"></a>00179       <span class="keywordflow">if</span> (<a class="code" href="classtlm__utils_1_1callback__binder__bw.html#6d967ce1ec96eed4a6133b0000279777">m_nb_f</a>-&gt;empty()){
<a name="l00180"></a>00180         std::cerr&lt;&lt;<span class="stringliteral">"No function registered"</span>&lt;&lt;std::endl;
<a name="l00181"></a>00181         exit(1);
<a name="l00182"></a>00182       }
<a name="l00183"></a>00183       <span class="keywordflow">else</span>
<a name="l00184"></a>00184         (*<a class="code" href="classtlm__utils_1_1callback__binder__bw.html#ed1334a5569a7a310236c58d65c63624">m_dmi_f</a>)(<a class="code" href="classtlm__utils_1_1callback__binder__bw.html#56f4eb80810779f77d6f9b76628b2427">m_id</a>,l,u); <span class="comment">//do the callback</span>
<a name="l00185"></a>00185     }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187     <span class="comment">//register callbacks for all bw interface methods at once</span>
<a name="l00188"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html#4fe3c4de09bc86fb5f1daba52a34b837">00188</a>     <span class="keywordtype">void</span> <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#4fe3c4de09bc86fb5f1daba52a34b837">set_callbacks</a>(<a class="code" href="classtlm__utils_1_1callback__binder__bw.html#bc32b114c0888ce732337c0b13891a03">nb_func_type</a>&amp; cb1, <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#8ce83c8584959c55a0a0319cdd27c59a">dmi_func_type</a>&amp; cb2){
<a name="l00189"></a>00189       <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#6d967ce1ec96eed4a6133b0000279777">m_nb_f</a>=&amp;cb1;
<a name="l00190"></a>00190       <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#ed1334a5569a7a310236c58d65c63624">m_dmi_f</a>=&amp;cb2;
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192     
<a name="l00193"></a>00193   <span class="keyword">private</span>:
<a name="l00194"></a>00194     <span class="comment">//the ID of the callback binder</span>
<a name="l00195"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html#56f4eb80810779f77d6f9b76628b2427">00195</a>     <span class="keywordtype">int</span> <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#56f4eb80810779f77d6f9b76628b2427">m_id</a>;
<a name="l00196"></a>00196     <span class="comment">//the callbacks</span>
<a name="l00197"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html#6d967ce1ec96eed4a6133b0000279777">00197</a>     <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#bc32b114c0888ce732337c0b13891a03">nb_func_type</a>* <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#6d967ce1ec96eed4a6133b0000279777">m_nb_f</a>;
<a name="l00198"></a><a class="code" href="classtlm__utils_1_1callback__binder__bw.html#ed1334a5569a7a310236c58d65c63624">00198</a>     <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#8ce83c8584959c55a0a0319cdd27c59a">dmi_func_type</a>* <a class="code" href="classtlm__utils_1_1callback__binder__bw.html#ed1334a5569a7a310236c58d65c63624">m_dmi_f</a>;
<a name="l00199"></a>00199 };
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="comment">/*</span>
<a name="l00203"></a>00203 <span class="comment">This class forms the base for multi initiator sockets.</span>
<a name="l00204"></a>00204 <span class="comment">It enforces a multi initiator socket to implement all functions</span>
<a name="l00205"></a>00205 <span class="comment">needed to do hierarchical bindings.</span>
<a name="l00206"></a>00206 <span class="comment">*/</span>
<a name="l00207"></a>00207 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> BUSWIDTH = 32,
<a name="l00208"></a>00208           <span class="keyword">typename</span> TYPES = <a class="code" href="structtlm_1_1tlm__base__protocol__types.html">tlm::tlm_base_protocol_types</a>,
<a name="l00209"></a>00209           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N=0
<a name="l00210"></a>00210 <span class="preprocessor">#if !(defined SYSTEMC_VERSION &amp; SYSTEMC_VERSION &lt;= 20050714)</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span>          ,sc_core::sc_port_policy POL = sc_core::SC_ONE_OR_MORE_BOUND
<a name="l00212"></a>00212 <span class="preprocessor">#endif</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span>          &gt;
<a name="l00214"></a><a class="code" href="classtlm__utils_1_1multi__init__base.html">00214</a> <span class="keyword">class </span><a class="code" href="classtlm__utils_1_1multi__init__base.html">multi_init_base</a>: <span class="keyword">public</span> tlm::tlm_initiator_socket&lt;BUSWIDTH,
<a name="l00215"></a>00215                                                   TYPES,
<a name="l00216"></a>00216                                                   N
<a name="l00217"></a>00217 #if !(defined SYSTEMC_VERSION &amp; SYSTEMC_VERSION &lt;= 20050714)
<a name="l00218"></a>00218                                                   ,POL
<a name="l00219"></a>00219 #endif
<a name="l00220"></a>00220                                                   &gt;{
<a name="l00221"></a>00221 public:
<a name="l00222"></a>00222   <span class="comment">//typedef for the base type: the standard tlm initiator socket</span>
<a name="l00223"></a>00223   typedef tlm::tlm_initiator_socket&lt;BUSWIDTH,
<a name="l00224"></a>00224                               TYPES,
<a name="l00225"></a>00225                               N
<a name="l00226"></a>00226 #if !(defined SYSTEMC_VERSION &amp; SYSTEMC_VERSION &lt;= 20050714)
<a name="l00227"></a>00227                               ,POL
<a name="l00228"></a>00228 #endif
<a name="l00229"></a><a class="code" href="classtlm__utils_1_1multi__init__base.html#e1fb493af5a99334fde5c145e081c2b2">00229</a>                               &gt; base_type;
<a name="l00230"></a>00230   
<a name="l00231"></a>00231   <span class="comment">//this method shall disable the code that does the callback binding</span>
<a name="l00232"></a>00232   <span class="comment">// that registers callbacks to binders</span>
<a name="l00233"></a>00233   virtual void disable_cb_bind()=0;
<a name="l00234"></a>00234   
<a name="l00235"></a>00235   <span class="comment">//this method shall return the multi_init_base to which the</span>
<a name="l00236"></a>00236   <span class="comment">// multi_init_base is bound hierarchically</span>
<a name="l00237"></a>00237   <span class="comment">//  If the base is not bound hierarchically it shall return a pointer to itself</span>
<a name="l00238"></a>00238   virtual multi_init_base* get_hierarch_bind()=0;
<a name="l00239"></a>00239   
<a name="l00240"></a>00240   <span class="comment">//this method shall return a vector of the callback binders of multi initiator socket</span>
<a name="l00241"></a>00241   virtual std::vector&lt;callback_binder_bw&lt;TYPES&gt;* &gt;&amp; get_binders()=0;
<a name="l00242"></a>00242   
<a name="l00243"></a>00243   <span class="comment">//this method shall return a vector of all target interfaces bound to this multi init socket</span>
<a name="l00244"></a>00244   virtual std::vector&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt;*&gt;&amp;  get_sockets()=0;
<a name="l00245"></a>00245   
<a name="l00246"></a>00246   <span class="comment">//ctor and dtor</span>
<a name="l00247"></a><a class="code" href="classtlm__utils_1_1multi__init__base.html#0a1966af80cf4e8ea8b59292949af60c">00247</a>   virtual ~multi_init_base(){}
<a name="l00248"></a><a class="code" href="classtlm__utils_1_1multi__init__base.html#d1f95759003604b94be4f9b301bc62f9">00248</a>   multi_init_base(const char* name):base_type(name){}
<a name="l00249"></a>00249 };
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="comment">/*</span>
<a name="l00252"></a>00252 <span class="comment">This class forms the base for multi target sockets.</span>
<a name="l00253"></a>00253 <span class="comment">It enforces a multi target socket to implement all functions</span>
<a name="l00254"></a>00254 <span class="comment">needed to do hierarchical bindings.</span>
<a name="l00255"></a>00255 <span class="comment">*/</span>
<a name="l00256"></a>00256 template &lt;unsigned int BUSWIDTH = 32,
<a name="l00257"></a>00257           typename TYPES = tlm::tlm_base_protocol_types,
<a name="l00258"></a>00258           unsigned int N=0
<a name="l00259"></a>00259 #if !(defined SYSTEMC_VERSION &amp; SYSTEMC_VERSION &lt;= 20050714)
<a name="l00260"></a>00260           ,sc_core::sc_port_policy POL = sc_core::SC_ONE_OR_MORE_BOUND
<a name="l00261"></a>00261 #endif
<a name="l00262"></a>00262           &gt;
<a name="l00263"></a><a class="code" href="classtlm__utils_1_1multi__target__base.html">00263</a> class multi_target_base: public tlm::tlm_target_socket&lt;BUSWIDTH, 
<a name="l00264"></a>00264                                                 TYPES,
<a name="l00265"></a>00265                                                 N
<a name="l00266"></a>00266 #if !(defined SYSTEMC_VERSION &amp; SYSTEMC_VERSION &lt;= 20050714)                                                
<a name="l00267"></a>00267                                                 ,POL
<a name="l00268"></a>00268 #endif
<a name="l00269"></a>00269                                                 &gt;{
<a name="l00270"></a>00270 public:
<a name="l00271"></a>00271   <span class="comment">//typedef for the base type: the standard tlm target socket</span>
<a name="l00272"></a>00272   typedef tlm::tlm_target_socket&lt;BUSWIDTH, 
<a name="l00273"></a>00273                               TYPES,
<a name="l00274"></a>00274                               N
<a name="l00275"></a>00275 #if !(defined SYSTEMC_VERSION &amp; SYSTEMC_VERSION &lt;= 20050714)
<a name="l00276"></a>00276                               ,POL
<a name="l00277"></a>00277 #endif
<a name="l00278"></a><a class="code" href="classtlm__utils_1_1multi__target__base.html#24471b5e2fe7411f621aca0b197d6485">00278</a>                               &gt; base_type;
<a name="l00279"></a>00279   
<a name="l00280"></a>00280   <span class="comment">//this method shall return the multi_init_base to which the</span>
<a name="l00281"></a>00281   <span class="comment">// multi_init_base is bound hierarchically</span>
<a name="l00282"></a>00282   <span class="comment">//  If the base is not bound hierarchically it shall return a pointer to itself                                                </span>
<a name="l00283"></a>00283   virtual multi_target_base* get_hierarch_bind()=0;
<a name="l00284"></a>00284   
<a name="l00285"></a>00285   <span class="comment">//this method shall inform the multi target socket that it is bound</span>
<a name="l00286"></a>00286   <span class="comment">// hierarchically and to which other multi target socket it is bound hierarchically</span>
<a name="l00287"></a>00287   virtual void set_hierarch_bind(multi_target_base*)=0;
<a name="l00288"></a>00288   
<a name="l00289"></a>00289   <span class="comment">//this method shall return a vector of the callback binders of multi initiator socket</span>
<a name="l00290"></a>00290   virtual std::vector&lt;callback_binder_fw&lt;TYPES&gt;* &gt;&amp; get_binders()=0;
<a name="l00291"></a>00291   
<a name="l00292"></a>00292   <span class="comment">//this method shall return a map of all multi initiator sockets that are bound to this multi target</span>
<a name="l00293"></a>00293   <span class="comment">// the key of the map is the index at which the multi initiator i bound, while the value</span>
<a name="l00294"></a>00294   <span class="comment">//  is the interface of the multi initiator socket that is bound at that index</span>
<a name="l00295"></a>00295   virtual std::map&lt;unsigned int, tlm::tlm_bw_transport_if&lt;TYPES&gt;*&gt;&amp;  get_multi_binds()=0;
<a name="l00296"></a>00296   
<a name="l00297"></a>00297   <span class="comment">//ctor and dtor</span>
<a name="l00298"></a><a class="code" href="classtlm__utils_1_1multi__target__base.html#df03dc930fca17ce85a79ede15e3601e">00298</a>   virtual ~multi_target_base(){}
<a name="l00299"></a><a class="code" href="classtlm__utils_1_1multi__target__base.html#500d3fc438d8348182842903304f0aea">00299</a>   multi_target_base(const char* name):base_type(name){}
<a name="l00300"></a>00300 };
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 <span class="comment">/*</span>
<a name="l00303"></a>00303 <span class="comment">All multi sockets must additionally derive from this class.</span>
<a name="l00304"></a>00304 <span class="comment">It enforces a multi socket to implement a function </span>
<a name="l00305"></a>00305 <span class="comment">needed to do multi init to multi target bindings.</span>
<a name="l00306"></a>00306 <span class="comment">*/</span>
<a name="l00307"></a>00307 template &lt;typename TYPES&gt;
<a name="l00308"></a><a class="code" href="classtlm__utils_1_1multi__to__multi__bind__base.html">00308</a> class multi_to_multi_bind_base{
<a name="l00309"></a>00309 public:
<a name="l00310"></a><a class="code" href="classtlm__utils_1_1multi__to__multi__bind__base.html#b823b6c7c9cac9785e29f2461a9ac6ab">00310</a>   virtual ~multi_to_multi_bind_base(){}
<a name="l00311"></a>00311   virtual tlm::tlm_fw_transport_if&lt;TYPES&gt;* get_last_binder(tlm::tlm_bw_transport_if&lt;TYPES&gt;*)=0;
<a name="l00312"></a>00312 };
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 #endif
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Thu Jun 5 17:43:03 2008 for TLM 2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
