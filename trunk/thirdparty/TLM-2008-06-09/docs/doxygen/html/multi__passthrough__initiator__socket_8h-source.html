<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TLM 2: C:/ESLX/projects/TLMWG/tlm2/include/tlm/tlm_utils/multi_passthrough_initiator_socket.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>C:/ESLX/projects/TLMWG/tlm2/include/tlm/tlm_utils/multi_passthrough_initiator_socket.h</h1><a href="multi__passthrough__initiator__socket_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  The following code is derived, directly or indirectly, from the SystemC</span>
<a name="l00004"></a>00004 <span class="comment">  source code Copyright (c) 1996-2008 by all Contributors.</span>
<a name="l00005"></a>00005 <span class="comment">  All Rights reserved.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">  The contents of this file are subject to the restrictions and limitations</span>
<a name="l00008"></a>00008 <span class="comment">  set forth in the SystemC Open Source License Version 3.0 (the "License");</span>
<a name="l00009"></a>00009 <span class="comment">  You may not use this file except in compliance with such restrictions and</span>
<a name="l00010"></a>00010 <span class="comment">  limitations. You may obtain instructions on how to receive a copy of the</span>
<a name="l00011"></a>00011 <span class="comment">  License at http://www.systemc.org/. Software distributed by Contributors</span>
<a name="l00012"></a>00012 <span class="comment">  under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF</span>
<a name="l00013"></a>00013 <span class="comment">  ANY KIND, either express or implied. See the License for the specific</span>
<a name="l00014"></a>00014 <span class="comment">  language governing rights and limitations under the License.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment"> *****************************************************************************/</span>
<a name="l00017"></a>00017 <span class="preprocessor">#ifndef __MULTI_PASSTHROUGH_INITIATOR_SOCKET_H__</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span><span class="preprocessor">#define __MULTI_PASSTHROUGH_INITIATOR_SOCKET_H__</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span>
<a name="l00020"></a>00020 <span class="preprocessor">#include "<a class="code" href="multi__socket__bases_8h.html">multi_socket_bases.h</a>"</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="keyword">namespace </span>tlm_utils {
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="comment">/*</span>
<a name="l00025"></a>00025 <span class="comment">This class implements a trivial multi initiator socket.</span>
<a name="l00026"></a>00026 <span class="comment">The triviality refers to the fact that the socket does not</span>
<a name="l00027"></a>00027 <span class="comment">do blocking to non-blocking or non-blocking to blocking conversions.</span>
<a name="l00028"></a>00028 <span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">It allows to connect multiple targets to this socket.</span>
<a name="l00030"></a>00030 <span class="comment">The user has to register callbacks for the bw interface methods</span>
<a name="l00031"></a>00031 <span class="comment">he likes to use. The callbacks are basically equal to the bw interface</span>
<a name="l00032"></a>00032 <span class="comment">methods but carry an additional integer that indicates to which</span>
<a name="l00033"></a>00033 <span class="comment">index of this socket the calling target is connected.</span>
<a name="l00034"></a>00034 <span class="comment">*/</span>
<a name="l00035"></a>00035 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MODULE,
<a name="l00036"></a>00036           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> BUSWIDTH = 32,
<a name="l00037"></a>00037           <span class="keyword">typename</span> TYPES = <a class="code" href="structtlm_1_1tlm__base__protocol__types.html">tlm::tlm_base_protocol_types</a>,
<a name="l00038"></a>00038           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N=0
<a name="l00039"></a>00039 <span class="preprocessor">#if !(defined SYSTEMC_VERSION &amp; SYSTEMC_VERSION &lt;= 20050714)</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>          ,sc_core::sc_port_policy POL = sc_core::SC_ONE_OR_MORE_BOUND
<a name="l00041"></a>00041 <span class="preprocessor">#endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>          &gt;
<a name="l00043"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html">00043</a> <span class="keyword">class </span><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html">multi_passthrough_initiator_socket</a>: <span class="keyword">public</span> <a class="code" href="classtlm__utils_1_1multi__init__base.html">multi_init_base</a>&lt; BUSWIDTH, 
<a name="l00044"></a>00044                                                         TYPES,
<a name="l00045"></a>00045                                                         N
<a name="l00046"></a>00046 #if !(defined SYSTEMC_VERSION &amp; SYSTEMC_VERSION &lt;= 20050714)
<a name="l00047"></a>00047                                                         ,POL
<a name="l00048"></a>00048 #endif
<a name="l00049"></a>00049                                                         &gt;
<a name="l00050"></a>00050 {
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 public:
<a name="l00053"></a>00053 
<a name="l00054"></a>00054   <span class="comment">//typedefs</span>
<a name="l00055"></a>00055   <span class="comment">//  tlm 2.0 types for nb_transport</span>
<a name="l00056"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#e79de77c20d9b10cf2f92103b6350f62">00056</a>   typedef typename TYPES::tlm_payload_type              transaction_type;
<a name="l00057"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#7b6f94171743062801eca26edde24efc">00057</a>   typedef typename TYPES::tlm_phase_type                phase_type;  
<a name="l00058"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#08b034d03da58f38e132f501d320406d">00058</a>   typedef tlm::tlm_sync_enum                            sync_enum_type;
<a name="l00059"></a>00059   
<a name="l00060"></a>00060   <span class="comment">//  typedefs to keep the fn ptr notations short</span>
<a name="l00061"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#9badafae6c38735558b937d4ed197179">00061</a>   typedef sync_enum_type (MODULE::*nb_cb)(int,
<a name="l00062"></a>00062                                          transaction_type&amp;,
<a name="l00063"></a>00063                                          phase_type&amp;,
<a name="l00064"></a>00064                                          sc_core::sc_time&amp;);
<a name="l00065"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#0191077f22bab9c26316c137a5ede0aa">00065</a>   typedef void (MODULE::*dmi_cb)(int, sc_dt::uint64, sc_dt::uint64);
<a name="l00066"></a>00066 
<a name="l00067"></a>00067   typedef multi_init_base&lt;BUSWIDTH, 
<a name="l00068"></a>00068                         TYPES,
<a name="l00069"></a>00069                         N
<a name="l00070"></a>00070 #if !(defined SYSTEMC_VERSION &amp; SYSTEMC_VERSION &lt;= 20050714)
<a name="l00071"></a>00071                         ,POL
<a name="l00072"></a>00072 #endif
<a name="l00073"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#f40922fe7533a7c87129c2cafb886c4e">00073</a>                         &gt; base_type;
<a name="l00074"></a>00074 
<a name="l00075"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#412be3159f765aab119920bdf9dbd8b4">00075</a>   typedef typename base_type::base_target_socket_type base_target_socket_type;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   <span class="comment">//CTOR</span>
<a name="l00078"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#25a32eb1ecb45740054faf167eaeb1e5">00078</a>   multi_passthrough_initiator_socket(const char* name)
<a name="l00079"></a>00079       : base_type((std::string(name)+std::string("_base")).c_str())
<a name="l00080"></a>00080       , m_mod(0)
<a name="l00081"></a>00081       , m_nb_cb(0)
<a name="l00082"></a>00082       , m_dmi_cb(0)
<a name="l00083"></a>00083       , m_hierarch_bind(0)
<a name="l00084"></a>00084       , m_beoe_disabled(false)
<a name="l00085"></a>00085       , m_dummy(42)
<a name="l00086"></a>00086   {
<a name="l00087"></a>00087   }
<a name="l00088"></a>00088 
<a name="l00089"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#1b1df1846b3b2ee6d3ca96712452ea06">00089</a>   ~multi_passthrough_initiator_socket(){
<a name="l00090"></a>00090     <span class="comment">//clean up everything allocated by 'new'</span>
<a name="l00091"></a>00091     for (unsigned int i=0; i&lt;m_binders.size(); i++) delete m_binders[i];
<a name="l00092"></a>00092   }
<a name="l00093"></a>00093   
<a name="l00094"></a>00094   <span class="comment">//simple helpers for warnings an errors to shorten in code notation</span>
<a name="l00095"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#34739a9de3aab6570e4b0c30dbd45d69">00095</a>   void display_warning(const std::string&amp; text){
<a name="l00096"></a>00096     std::stringstream s;
<a name="l00097"></a>00097     s&lt;&lt;"WARNING in instance "&lt;&lt;base_type::name()&lt;&lt;": "&lt;&lt;text;
<a name="l00098"></a>00098     SC_REPORT_WARNING("multi_socket", s.str().c_str());
<a name="l00099"></a>00099   }
<a name="l00100"></a>00100 
<a name="l00101"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#a4ced17c44352261d1e80b95422b7acc">00101</a>   void display_error(const std::string&amp; text){
<a name="l00102"></a>00102     std::stringstream s;
<a name="l00103"></a>00103     s&lt;&lt;"ERROR in instance "&lt;&lt;base_type::name()&lt;&lt;": "&lt;&lt;text;
<a name="l00104"></a>00104     SC_REPORT_ERROR("multi_socket", s.str().c_str());
<a name="l00105"></a>00105   }
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="comment">//register callback for nb transport of bw interface</span>
<a name="l00109"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#a71818a86f768d9e55c5a7e20f1cdb63">00109</a>   void register_nb_transport_bw(MODULE* mod,
<a name="l00110"></a>00110                               sync_enum_type (MODULE::*cb)(int,
<a name="l00111"></a>00111                                                            transaction_type&amp;,
<a name="l00112"></a>00112                                                            phase_type&amp;,
<a name="l00113"></a>00113                                                            sc_core::sc_time&amp;))
<a name="l00114"></a>00114   {
<a name="l00115"></a>00115     <span class="comment">//make sure that only one module is registering callbacks with this socket</span>
<a name="l00116"></a>00116     if (m_mod) assert(m_mod==mod);
<a name="l00117"></a>00117     else m_mod=mod;
<a name="l00118"></a>00118     
<a name="l00119"></a>00119     <span class="comment">//warn if there already is a callback</span>
<a name="l00120"></a>00120     if (m_nb_cb){
<a name="l00121"></a>00121       display_warning("NBTransport_bw callback already registered.");
<a name="l00122"></a>00122       return;
<a name="l00123"></a>00123     }
<a name="l00124"></a>00124     
<a name="l00125"></a>00125     <span class="comment">//store the callback and create the appropriate boost function</span>
<a name="l00126"></a>00126     m_nb_cb=cb;
<a name="l00127"></a>00127     m_nb_f=boost::bind&lt;sync_enum_type&gt;(boost::mem_fn(m_nb_cb) , m_mod, _1, _2, _3, _4);
<a name="l00128"></a>00128   }
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   <span class="comment">//register callback for dmi function of bw interface</span>
<a name="l00131"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#cb90f0f47ec64a9b3a47bd9c90f6884c">00131</a>   void register_invalidate_direct_mem_ptr(MODULE* mod,
<a name="l00132"></a>00132                              void (MODULE::*cb)(int, sc_dt::uint64, sc_dt::uint64))
<a name="l00133"></a>00133   {
<a name="l00134"></a>00134     <span class="comment">//make sure that only one module is registering callbacks with this socket</span>
<a name="l00135"></a>00135     if (m_mod) assert(m_mod==mod);
<a name="l00136"></a>00136     else m_mod=mod;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138     <span class="comment">//warn if there already is a callback</span>
<a name="l00139"></a>00139     if (m_dmi_cb){
<a name="l00140"></a>00140       display_warning("InvalidateDMI callback already registered.");
<a name="l00141"></a>00141       return;
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143     
<a name="l00144"></a>00144     <span class="comment">//store the callback and create the appropriate boost function</span>
<a name="l00145"></a>00145     m_dmi_cb=cb;
<a name="l00146"></a>00146     m_dmi_f=boost::bind&lt;void&gt;(boost::mem_fn(m_dmi_cb), m_mod, _1, _2, _3);
<a name="l00147"></a>00147   }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149   <span class="comment">//Override virtual functions of the tlm_initiator_socket:</span>
<a name="l00150"></a>00150   <span class="comment">// this function is called whenever an sc_port (as part of a target socket)</span>
<a name="l00151"></a>00151   <span class="comment">//  wants to bind to the export of the underlying tlm_initiator_socket</span>
<a name="l00152"></a>00152   <span class="comment">//At this time a callback binder is created an returned to the sc_port</span>
<a name="l00153"></a>00153   <span class="comment">// of the target socket, so that it binds to the callback binder</span>
<a name="l00154"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#9d4d6d139eacaa8ad6acf87ae3889115">00154</a>   virtual tlm::tlm_bw_transport_if&lt;TYPES&gt;&amp; get_base_interface()
<a name="l00155"></a>00155   {
<a name="l00156"></a>00156     m_binders.push_back(new callback_binder_bw&lt;TYPES&gt;(m_binders.size()));
<a name="l00157"></a>00157     return *m_binders[m_binders.size()-1];
<a name="l00158"></a>00158   }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   <span class="comment">//Override virtual functions of the tlm_initiator_socket:</span>
<a name="l00161"></a>00161   <span class="comment">// this function is called whenever an sc_export (as part of a initiator socket)</span>
<a name="l00162"></a>00162   <span class="comment">//  wants to bind to the export of the underlying tlm_initiator_socket</span>
<a name="l00163"></a>00163   <span class="comment">//   i.e. a hierarchical bind takes place</span>
<a name="l00164"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#35beeda7838ceda497f6717549211d19">00164</a>   virtual sc_core::sc_export&lt;tlm::tlm_bw_transport_if&lt;TYPES&gt; &gt;&amp; get_base_export()
<a name="l00165"></a>00165   {
<a name="l00166"></a>00166     if (!m_beoe_disabled) <span class="comment">//we are not bound hierarchically</span>
<a name="l00167"></a>00167       base_type::m_export.bind(m_dummy);  <span class="comment">//so we bind the dummy to avoid a SystemC error</span>
<a name="l00168"></a>00168     return base_type::m_export; <span class="comment">//and then return our own export so that the hierarchical binding is set up properly</span>
<a name="l00169"></a>00169   }
<a name="l00170"></a>00170 
<a name="l00171"></a>00171   <span class="comment">//bind against a target socket</span>
<a name="l00172"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#2b1c632fdc796b1b87589a960b096e1c">00172</a>   void bind(base_target_socket_type&amp; s)
<a name="l00173"></a>00173   {
<a name="l00174"></a>00174     <span class="comment">//error if this socket is already bound hierarchically</span>
<a name="l00175"></a>00175     if (m_hierarch_bind)
<a name="l00176"></a>00176       display_error("Already hierarchically bound.");     
<a name="l00177"></a>00177        
<a name="l00178"></a>00178     base_type::bind(s); <span class="comment">//satisfy systemC, leads to a call to get_base_interface()</span>
<a name="l00179"></a>00179     
<a name="l00180"></a>00180     <span class="comment">//try to cast the target socket into a fw interface</span>
<a name="l00181"></a>00181     sc_core::sc_export&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt; &gt;* p_ex_s=dynamic_cast&lt;sc_core::sc_export&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt; &gt;*&gt;(&amp;s);
<a name="l00182"></a>00182     if (!p_ex_s) display_error("Multi socket not bound to tlm_socket.");
<a name="l00183"></a>00183     
<a name="l00184"></a>00184     <span class="comment">//try a cast into a multi sockets</span>
<a name="l00185"></a>00185     multi_to_multi_bind_base&lt;TYPES&gt;* test=dynamic_cast&lt;multi_to_multi_bind_base&lt;TYPES&gt;*&gt; (p_ex_s);
<a name="l00186"></a>00186     if (test) <span class="comment">//did we just do a multi-multi bind??</span>
<a name="l00187"></a>00187       <span class="comment">//if that is the case the multi target socket must have just created a callback binder</span>
<a name="l00188"></a>00188       <span class="comment">// which we want to get from it.</span>
<a name="l00189"></a>00189       <span class="comment">//Moreover, we also just created one, which we will pass to it.</span>
<a name="l00190"></a>00190       m_sockets.push_back(test-&gt;get_last_binder(m_binders[m_binders.size()-1])); 
<a name="l00191"></a>00191     else{  <span class="comment">// if not just bind normally</span>
<a name="l00192"></a>00192       sc_core::sc_export&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt; &gt;&amp; ex_s=*p_ex_s;
<a name="l00193"></a>00193       m_sockets.push_back(&amp;((tlm::tlm_fw_transport_if&lt;TYPES&gt;&amp;)ex_s)); <span class="comment">//store the interface we are bound against</span>
<a name="l00194"></a>00194     }
<a name="l00195"></a>00195   }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="comment">//operator notation for direct bind</span>
<a name="l00198"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#f732774c680a658512af6860f21037d1">00198</a>   void operator() (base_target_socket_type&amp; s)
<a name="l00199"></a>00199   {
<a name="l00200"></a>00200     bind(s);
<a name="l00201"></a>00201   }
<a name="l00202"></a>00202   
<a name="l00203"></a>00203   <span class="comment">//SystemC standard callback before end of elaboration</span>
<a name="l00204"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#6c55374f7d5e9b6c4b0f4c9ee4f7e456">00204</a>   void before_end_of_elaboration(){
<a name="l00205"></a>00205     <span class="comment">//if our export hasn't been bound yet (due to a hierarch binding)</span>
<a name="l00206"></a>00206     <span class="comment">// we bind it now to avoid a SystemC error.</span>
<a name="l00207"></a>00207     <span class="comment">//We must do that, because it is legal not to register a callback on this socket</span>
<a name="l00208"></a>00208     <span class="comment">// as the user might only use b_transport</span>
<a name="l00209"></a>00209     if (!base_type::m_export.get_interface()){ 
<a name="l00210"></a>00210       base_type::m_export.bind(m_dummy);      
<a name="l00211"></a>00211     }
<a name="l00212"></a>00212     
<a name="l00213"></a>00213     <span class="comment">//'break' here if the socket was told not to do callback binding</span>
<a name="l00214"></a>00214     if (m_beoe_disabled) return;
<a name="l00215"></a>00215     
<a name="l00216"></a>00216     <span class="comment">//get the callback binders of the top of the hierachical bind chain</span>
<a name="l00217"></a>00217     <span class="comment">// NOTE: this could be the same socket if there is no hierachical bind</span>
<a name="l00218"></a>00218     std::vector&lt;callback_binder_bw&lt;TYPES&gt;* &gt;&amp; binders=get_hierarch_bind()-&gt;get_binders();
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     <span class="comment">//get the interfaces bound to the top of the hierachical bind chain</span>
<a name="l00221"></a>00221     <span class="comment">// NOTE: this could be the same socket if there is no hierachical bind</span>
<a name="l00222"></a>00222     m_used_sockets=get_hierarch_bind()-&gt;get_sockets();
<a name="l00223"></a>00223     
<a name="l00224"></a>00224     <span class="comment">//register the callbacks of this socket with the callback binders</span>
<a name="l00225"></a>00225     <span class="comment">// we just got from the top of the hierachical bind chain</span>
<a name="l00226"></a>00226     for (unsigned int i=0; i&lt;binders.size(); i++) {
<a name="l00227"></a>00227       binders[i]-&gt;set_callbacks(m_nb_f, m_dmi_f);
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229   }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231   <span class="comment">//</span>
<a name="l00232"></a>00232   <span class="comment">// Bind multi initiator socket to multi initiator socket (hierarchical bind)</span>
<a name="l00233"></a>00233   <span class="comment">//</span>
<a name="l00234"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#33b278874b8f5b93965f5d8fc55b58bb">00234</a>   void bind(base_type&amp; s)
<a name="l00235"></a>00235   {
<a name="l00236"></a>00236     if (m_binders.size()) <span class="comment">//a multi socket is either bound hierarchically or directly</span>
<a name="l00237"></a>00237       display_error("Socket already directly bound.");
<a name="l00238"></a>00238     if (m_hierarch_bind){
<a name="l00239"></a>00239       display_warning("Socket already bound hierarchically. Bind attempt ignored.");
<a name="l00240"></a>00240       return;
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242     
<a name="l00243"></a>00243     <span class="comment">//remember to which socket we are hierarchically bound and disable it, </span>
<a name="l00244"></a>00244     <span class="comment">// so that it won't try to register callbacks itself</span>
<a name="l00245"></a>00245     s.disable_cb_bind();
<a name="l00246"></a>00246     m_hierarch_bind=&amp;s;    
<a name="l00247"></a>00247     base_type::bind(s); <span class="comment">//satisfy SystemC</span>
<a name="l00248"></a>00248   }
<a name="l00249"></a>00249 
<a name="l00250"></a>00250   <span class="comment">//operator notation for hierarchical bind</span>
<a name="l00251"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#14200c1b573e7e096913535b0f2e3e6f">00251</a>   void operator() (base_type&amp; s)
<a name="l00252"></a>00252   {
<a name="l00253"></a>00253     bind(s);
<a name="l00254"></a>00254   }
<a name="l00255"></a>00255 
<a name="l00256"></a>00256   <span class="comment">//get access to sub port</span>
<a name="l00257"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#41797e7abe235f3c5e6efd3c246b8d8a">00257</a>   tlm::tlm_fw_transport_if&lt;TYPES&gt;* operator[](int i){return m_used_sockets[i];}
<a name="l00258"></a>00258   
<a name="l00259"></a>00259   <span class="comment">//get the number of bound targets</span>
<a name="l00260"></a>00260   <span class="comment">// NOTE: this is only valid at end of elaboration!</span>
<a name="l00261"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#7c2d6187d9de379f06007c4085ce7d32">00261</a>   unsigned int size() {return get_hierarch_bind()-&gt;get_sockets().size();}
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 protected:
<a name="l00264"></a>00264   <span class="comment">//implementation of base class interface</span>
<a name="l00265"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#f160c9ebe2b88f8b3f266effea94d571">00265</a>   base_type* get_hierarch_bind(){if (m_hierarch_bind) return m_hierarch_bind-&gt;get_hierarch_bind(); else return this;}
<a name="l00266"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#a5dcdec260f84b5dfa514726f9b3b694">00266</a>   void disable_cb_bind(){ m_beoe_disabled=true;}
<a name="l00267"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#4bcf3102e9bc2a903675b413c6b249aa">00267</a>   std::vector&lt;callback_binder_bw&lt;TYPES&gt;* &gt;&amp; get_binders(){return m_binders;}
<a name="l00268"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#f2eab34a10975b7566e385d0ee7cb04e">00268</a>   std::vector&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt;*&gt;&amp; get_sockets(){return m_sockets;}
<a name="l00269"></a>00269   <span class="comment">//vector of connected sockets</span>
<a name="l00270"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#51a25ff90a86be76a0039fd94063790b">00270</a>   std::vector&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt;*&gt; m_sockets;
<a name="l00271"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#55b13a553f43a092ad6a97ca7d98c8a4">00271</a>   std::vector&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt;*&gt; m_used_sockets;
<a name="l00272"></a>00272   <span class="comment">//vector of binders that convert untagged interface into tagged interface</span>
<a name="l00273"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#4abda8ae69c353b31ed06065ef7afcfd">00273</a>   std::vector&lt;callback_binder_bw&lt;TYPES&gt;*&gt; m_binders;
<a name="l00274"></a>00274   
<a name="l00275"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#98b0420a334bf961ea9989165399cfec">00275</a>   MODULE* m_mod; <span class="comment">//the owning module</span>
<a name="l00276"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#c1cb6ca587f06ba2ca9d01505b0b7fb1">00276</a>   nb_cb   m_nb_cb; <span class="comment">//the nb callback of the owning module</span>
<a name="l00277"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#10464cc95ffe0e004239e072b85f4340">00277</a>   dmi_cb  m_dmi_cb; <span class="comment">//the dmi callback of the owning module</span>
<a name="l00278"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#c8f30a18afbb343f48a3b204555181fb">00278</a>   base_type*  m_hierarch_bind; <span class="comment">//pointer to hierarchical bound multi port</span>
<a name="l00279"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#ef91eeb042540b72d334be6ef94be5b2">00279</a>   bool m_beoe_disabled;  <span class="comment">// bool that remembers whether this socket shall bind callbacks or not</span>
<a name="l00280"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#d52c193b2ea265be7410b0ee9632d786">00280</a>   callback_binder_bw&lt;TYPES&gt; m_dummy; <span class="comment">//a callback binder that is bound to the underlying export</span>
<a name="l00281"></a>00281                                      <span class="comment">// in case there was no real bind</span>
<a name="l00282"></a>00282 
<a name="l00283"></a>00283   <span class="comment">//callbacks as boost functions</span>
<a name="l00284"></a>00284   <span class="comment">// (allows to pass the callback to another socket that does not know the type of the module that owns</span>
<a name="l00285"></a>00285   <span class="comment">//  the callbacks)</span>
<a name="l00286"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#b38cd67e188ad1387441faa32af69b35">00286</a>   boost::function&lt;sync_enum_type (int i, transaction_type&amp; txn, phase_type&amp; p, sc_core::sc_time&amp; t)&gt; m_nb_f;
<a name="l00287"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#30e249c53717e736b6c37447b5a86161">00287</a>   boost::function&lt;void (int i, sc_dt::uint64 l, sc_dt::uint64 u)&gt; m_dmi_f;
<a name="l00288"></a>00288 };
<a name="l00289"></a>00289 
<a name="l00290"></a>00290 }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 #endif
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Thu Jun 5 17:43:03 2008 for TLM 2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
