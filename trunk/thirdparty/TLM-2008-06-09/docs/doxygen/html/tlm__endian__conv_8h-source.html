<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TLM 2: C:/ESLX/projects/TLMWG/tlm2/include/tlm/tlm_h/tlm_trans/tlm_generic_payload/tlm_endian_conv.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>C:/ESLX/projects/TLMWG/tlm2/include/tlm/tlm_h/tlm_trans/tlm_generic_payload/tlm_endian_conv.h</h1><a href="tlm__endian__conv_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  The following code is derived, directly or indirectly, from the SystemC</span>
<a name="l00004"></a>00004 <span class="comment">  source code Copyright (c) 1996-2008 by all Contributors.</span>
<a name="l00005"></a>00005 <span class="comment">  All Rights reserved.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">  The contents of this file are subject to the restrictions and limitations</span>
<a name="l00008"></a>00008 <span class="comment">  set forth in the SystemC Open Source License Version 3.0 (the "License");</span>
<a name="l00009"></a>00009 <span class="comment">  You may not use this file except in compliance with such restrictions and</span>
<a name="l00010"></a>00010 <span class="comment">  limitations. You may obtain instructions on how to receive a copy of the</span>
<a name="l00011"></a>00011 <span class="comment">  License at http://www.systemc.org/. Software distributed by Contributors</span>
<a name="l00012"></a>00012 <span class="comment">  under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF</span>
<a name="l00013"></a>00013 <span class="comment">  ANY KIND, either express or implied. See the License for the specific</span>
<a name="l00014"></a>00014 <span class="comment">  language governing rights and limitations under the License.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">*****************************************************************************/</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#ifndef __TLM_ENDIAN_CONV_H__</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#define __TLM_ENDIAN_CONV_H__</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;systemc&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include "<a class="code" href="tlm__gp_8h.html">tlm_gp.h</a>"</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="keyword">namespace </span>tlm {
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="comment">/*</span>
<a name="l00030"></a>00030 <span class="comment">Tranaction-Level Modelling</span>
<a name="l00031"></a>00031 <span class="comment">Endianness Helper Functions</span>
<a name="l00032"></a>00032 <span class="comment"></span>
<a name="l00033"></a>00033 <span class="comment">DESCRIPTION</span>
<a name="l00034"></a>00034 <span class="comment">A set of functions for helping users to get the endianness</span>
<a name="l00035"></a>00035 <span class="comment">right in their TLM models of system initiators.  These functions are</span>
<a name="l00036"></a>00036 <span class="comment">for use within an initiator.  They can not be used as-is outside</span>
<a name="l00037"></a>00037 <span class="comment">an initiator because the extension used to store context will not work</span>
<a name="l00038"></a>00038 <span class="comment">if cascaded, and they do not respect the generic payload mutability</span>
<a name="l00039"></a>00039 <span class="comment">rules.  However this code may be easily copied and adapted for use</span>
<a name="l00040"></a>00040 <span class="comment">in bridges, etc..</span>
<a name="l00041"></a>00041 <span class="comment"></span>
<a name="l00042"></a>00042 <span class="comment">These functions are not compulsory.  There are other legitimate ways to</span>
<a name="l00043"></a>00043 <span class="comment">achieve the same functionality.  If extra information is available at</span>
<a name="l00044"></a>00044 <span class="comment">compile time about the nature of an initiator's transactions, this can</span>
<a name="l00045"></a>00045 <span class="comment">be exploited to accelerate simulations by creating further functions</span>
<a name="l00046"></a>00046 <span class="comment">similar to those in this file.  In general a functional transaction can be</span>
<a name="l00047"></a>00047 <span class="comment">described in more than one way by a TLM-2 GP object.</span>
<a name="l00048"></a>00048 <span class="comment"></span>
<a name="l00049"></a>00049 <span class="comment">The functions convert the endianness of a GP object, either on request or</span>
<a name="l00050"></a>00050 <span class="comment">response.  They should only be used when the initiator's endianness</span>
<a name="l00051"></a>00051 <span class="comment">does not match the host's endianness.  They assume 'arithmetic mode'</span>
<a name="l00052"></a>00052 <span class="comment">meaning that within a data word the byte order is always host-endian.</span>
<a name="l00053"></a>00053 <span class="comment">For non-arithmetic mode initiators they can be used with a data word</span>
<a name="l00054"></a>00054 <span class="comment">size of 1 byte.</span>
<a name="l00055"></a>00055 <span class="comment"></span>
<a name="l00056"></a>00056 <span class="comment">All the functions are templates, for example:</span>
<a name="l00057"></a>00057 <span class="comment"></span>
<a name="l00058"></a>00058 <span class="comment">template&lt;class DATAWORD&gt; inline void</span>
<a name="l00059"></a>00059 <span class="comment">  to_hostendian_generic(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00060"></a>00060 <span class="comment"></span>
<a name="l00061"></a>00061 <span class="comment">The template parameter provides the data word width.  Having this as a class</span>
<a name="l00062"></a>00062 <span class="comment">makes it easy to use it for copy and swap operations within the functions.</span>
<a name="l00063"></a>00063 <span class="comment">If the assignment operator for this class is overloaded, the endianness</span>
<a name="l00064"></a>00064 <span class="comment">conversion function may not have the desired effect.</span>
<a name="l00065"></a>00065 <span class="comment"></span>
<a name="l00066"></a>00066 <span class="comment">All the functions have the same signature except for different names.</span>
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment">The principle is that a function to_hostendian_convtype() is called when the</span>
<a name="l00069"></a>00069 <span class="comment">initiator-endian transaction is created, and the matching function</span>
<a name="l00070"></a>00070 <span class="comment">from_hostendian_convtype() is called when the transaction is completed, for</span>
<a name="l00071"></a>00071 <span class="comment">example before read data can be used.  In some cases the from_ function is</span>
<a name="l00072"></a>00072 <span class="comment">redundant but an empty function is provided anyway.  It is strongly</span>
<a name="l00073"></a>00073 <span class="comment">recommended that the from_ function is called, in case it ceases to be</span>
<a name="l00074"></a>00074 <span class="comment">redundant in future versions of this code.</span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">No context needs to be managed outside the two functions, except that they</span>
<a name="l00077"></a>00077 <span class="comment">must be called with the same template parameter and the same bus width.</span>
<a name="l00078"></a>00078 <span class="comment"></span>
<a name="l00079"></a>00079 <span class="comment">For initiator models that can not easily manage this context information,</span>
<a name="l00080"></a>00080 <span class="comment">a single entry point for the from_ function is provided, which will be</span>
<a name="l00081"></a>00081 <span class="comment">a little slower than calling the correct from_ function directly, as</span>
<a name="l00082"></a>00082 <span class="comment">it can not be inlined.</span>
<a name="l00083"></a>00083 <span class="comment"></span>
<a name="l00084"></a>00084 <span class="comment">All functions assume power-of-2 bus and data word widths.</span>
<a name="l00085"></a>00085 <span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment">Functions offered:</span>
<a name="l00087"></a>00087 <span class="comment"></span>
<a name="l00088"></a>00088 <span class="comment">0) A pair of functions that work for almost all TLM2 GP transactions.  The</span>
<a name="l00089"></a>00089 <span class="comment">only limitations are that data and bus widths should be powers of 2, and that</span>
<a name="l00090"></a>00090 <span class="comment">the data length should be an integer number of streaming widths and that the</span>
<a name="l00091"></a>00091 <span class="comment">streaming width should be an integer number of data words.</span>
<a name="l00092"></a>00092 <span class="comment">These functions always allocate new data and byte enable buffers and copy</span>
<a name="l00093"></a>00093 <span class="comment">data one byte at a time.</span>
<a name="l00094"></a>00094 <span class="comment">  tlm_to_hostendian_generic(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00095"></a>00095 <span class="comment">  tlm_from_hostendian_generic(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00096"></a>00096 <span class="comment"></span>
<a name="l00097"></a>00097 <span class="comment">1) A pair of functions that work for all transactions regardless of data and</span>
<a name="l00098"></a>00098 <span class="comment">bus data sizes and address alignment except for the the following</span>
<a name="l00099"></a>00099 <span class="comment">limitations:</span>
<a name="l00100"></a>00100 <span class="comment">- byte-enables are supported only when byte-enable granularity is no finer</span>
<a name="l00101"></a>00101 <span class="comment">than the data word (every data word is wholly enabled or wholly disabled)</span>
<a name="l00102"></a>00102 <span class="comment">- byte-enable-length is not supported (if byte enables are present, the byte</span>
<a name="l00103"></a>00103 <span class="comment">enable length must be equal to the data length).</span>
<a name="l00104"></a>00104 <span class="comment">- streaming width is not supported</span>
<a name="l00105"></a>00105 <span class="comment">- data word wider than bus word is not supported</span>
<a name="l00106"></a>00106 <span class="comment">A new data buffer and a new byte enable buffer are always allocated.  Byte</span>
<a name="l00107"></a>00107 <span class="comment">enables are assumed to be needed even if not required for the original</span>
<a name="l00108"></a>00108 <span class="comment">(unconverted) transaction.  Data is copied to the new buffer on request</span>
<a name="l00109"></a>00109 <span class="comment">(for writes) or on response (for reads).  Copies are done word-by-word</span>
<a name="l00110"></a>00110 <span class="comment">where possible.</span>
<a name="l00111"></a>00111 <span class="comment">  tlm_to_hostendian_word(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00112"></a>00112 <span class="comment">  tlm_from_hostendian_word(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00113"></a>00113 <span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment">2) If the original transaction is both word and bus-aligned then this pair of</span>
<a name="l00115"></a>00115 <span class="comment">functions can be used.  It will complete faster than the generic function</span>
<a name="l00116"></a>00116 <span class="comment">because the data reordering function is much simpler and no address</span>
<a name="l00117"></a>00117 <span class="comment">conversion is required.</span>
<a name="l00118"></a>00118 <span class="comment">The following limitations apply:</span>
<a name="l00119"></a>00119 <span class="comment">- byte-enables are supported only when byte-enable granularity is no finer</span>
<a name="l00120"></a>00120 <span class="comment">than the data word (every data word is wholly enabled or wholly disabled)</span>
<a name="l00121"></a>00121 <span class="comment">- byte-enable-length is not supported (if byte enables are present, the byte</span>
<a name="l00122"></a>00122 <span class="comment">enable length must be equal to the data length).</span>
<a name="l00123"></a>00123 <span class="comment">- streaming width is not supported</span>
<a name="l00124"></a>00124 <span class="comment">- data word wider than bus word is not supported</span>
<a name="l00125"></a>00125 <span class="comment">- the transaction must be an integer number of bus words</span>
<a name="l00126"></a>00126 <span class="comment">- the address must be aligned to the bus width</span>
<a name="l00127"></a>00127 <span class="comment">  tlm_to_hostendian_aligned(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00128"></a>00128 <span class="comment">  tlm_from_hostendian_aligned(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00129"></a>00129 <span class="comment"></span>
<a name="l00130"></a>00130 <span class="comment">3) For single word transactions that don't cross a bus word boundary it</span>
<a name="l00131"></a>00131 <span class="comment">is always safe to work in-place and the conversion is very simple.  Again,</span>
<a name="l00132"></a>00132 <span class="comment">streaming width and byte-enable length are not supported, and byte-enables</span>
<a name="l00133"></a>00133 <span class="comment">may not changes within a data word.</span>
<a name="l00134"></a>00134 <span class="comment">  tlm_to_hostendian_single(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00135"></a>00135 <span class="comment">  tlm_from_hostendian_single(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00136"></a>00136 <span class="comment"></span>
<a name="l00137"></a>00137 <span class="comment">4) A single entry point for accessing the correct from_ function without</span>
<a name="l00138"></a>00138 <span class="comment">needing to store context.</span>
<a name="l00139"></a>00139 <span class="comment">  tlm_from_hostendian(tlm_generic_payload *txn)</span>
<a name="l00140"></a>00140 <span class="comment">*/</span>
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="preprocessor">#ifndef uchar</span>
<a name="l00143"></a><a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">00143</a> <span class="preprocessor"></span><span class="preprocessor">#define uchar unsigned char</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span><span class="preprocessor">#define TLM_END_CONV_DONT_UNDEF_UCHAR</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00147"></a>00147 <span class="preprocessor"></span>
<a name="l00149"></a>00149 <span class="comment">// Generic Utilities</span>
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="comment">// a pool for uchar* buffers of arbitrary but bounded size.  the pool contains</span>
<a name="l00152"></a>00152 <span class="comment">// buffers with a fixed size - the largest so far requested.</span>
<a name="l00153"></a><a class="code" href="classtlm_1_1tlm__buffer__pool.html">00153</a> <span class="keyword">class </span><a class="code" href="classtlm_1_1tlm__buffer__pool.html">tlm_buffer_pool</a> {
<a name="l00154"></a><a class="code" href="classtlm_1_1tlm__buffer__pool.html#cc6344c000755eed939feb53dab6b474">00154</a>   <span class="keywordtype">int</span> <a class="code" href="classtlm_1_1tlm__buffer__pool.html#cc6344c000755eed939feb53dab6b474">max_buffer_size</a>;
<a name="l00155"></a><a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">00155</a>   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>* <a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a>;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157   <span class="keyword">public</span>:
<a name="l00158"></a><a class="code" href="classtlm_1_1tlm__buffer__pool.html#169dbf00bb971fe9fc5a66fe38a94bba">00158</a>     <a class="code" href="classtlm_1_1tlm__buffer__pool.html#169dbf00bb971fe9fc5a66fe38a94bba">tlm_buffer_pool</a>(): <a class="code" href="classtlm_1_1tlm__buffer__pool.html#cc6344c000755eed939feb53dab6b474">max_buffer_size</a>(32), <a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a>(0) {};
<a name="l00159"></a>00159 
<a name="l00160"></a><a class="code" href="classtlm_1_1tlm__buffer__pool.html#4f26fed0eba7796a462b4e13258488cc">00160</a>     <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *<a class="code" href="classtlm_1_1tlm__buffer__pool.html#4f26fed0eba7796a462b4e13258488cc">get_a_buffer</a>(<span class="keywordtype">int</span> size) {
<a name="l00161"></a>00161       <span class="keywordflow">if</span>(size &gt; <a class="code" href="classtlm_1_1tlm__buffer__pool.html#cc6344c000755eed939feb53dab6b474">max_buffer_size</a>) {
<a name="l00162"></a>00162         <a class="code" href="classtlm_1_1tlm__buffer__pool.html#cc6344c000755eed939feb53dab6b474">max_buffer_size</a> = size;
<a name="l00163"></a>00163         <span class="comment">// empty the pool - it will have to grow again naturally</span>
<a name="l00164"></a>00164         <span class="keywordflow">for</span>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *p = <a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a>; p != 0; ) {
<a name="l00165"></a>00165           <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *q = p;
<a name="l00166"></a>00166           p = *((<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> **)(p + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)));
<a name="l00167"></a>00167           <span class="keyword">delete</span> [] q;
<a name="l00168"></a>00168         }
<a name="l00169"></a>00169         <a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a> = 0;
<a name="l00170"></a>00170       }
<a name="l00171"></a>00171       <span class="keywordflow">if</span>(<a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a> == 0) {
<a name="l00172"></a>00172         <span class="comment">// do a real malloc because pool is empty</span>
<a name="l00173"></a>00173         <span class="comment">// allocate 2 spare spaces, one for the size and the other for the</span>
<a name="l00174"></a>00174         <span class="comment">// next-pointer</span>
<a name="l00175"></a>00175         <a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a> = <span class="keyword">new</span> <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>[<a class="code" href="classtlm_1_1tlm__buffer__pool.html#cc6344c000755eed939feb53dab6b474">max_buffer_size</a> + <span class="keyword">sizeof</span>(int) + <span class="keyword">sizeof</span>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)];
<a name="l00176"></a>00176         *((<span class="keywordtype">int</span> *)<a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a>) = <a class="code" href="classtlm_1_1tlm__buffer__pool.html#cc6344c000755eed939feb53dab6b474">max_buffer_size</a>;
<a name="l00177"></a>00177         *((<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> **)(<a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a> + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>))) = 0;
<a name="l00178"></a>00178       }
<a name="l00179"></a>00179       <span class="comment">// now pop the pool and return the old head</span>
<a name="l00180"></a>00180       <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *retval = <a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a> + <span class="keyword">sizeof</span>(int) + <span class="keyword">sizeof</span>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *);
<a name="l00181"></a>00181       <a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a> = *((<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> **)(<a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a> + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)));
<a name="l00182"></a>00182       <span class="keywordflow">return</span> retval;
<a name="l00183"></a>00183     };
<a name="l00184"></a>00184 
<a name="l00185"></a><a class="code" href="classtlm_1_1tlm__buffer__pool.html#906b255f8acff3bfaf550c864d9ee05a">00185</a>     <span class="keywordtype">void</span> <a class="code" href="classtlm_1_1tlm__buffer__pool.html#906b255f8acff3bfaf550c864d9ee05a">return_buffer</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *p) {
<a name="l00186"></a>00186       <span class="comment">// calculate the start of the actual buffer</span>
<a name="l00187"></a>00187       <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *q = p - <span class="keyword">sizeof</span>(int) - <span class="keyword">sizeof</span>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *);
<a name="l00188"></a>00188       <span class="keywordflow">if</span>(*((<span class="keywordtype">int</span> *)q) != <a class="code" href="classtlm_1_1tlm__buffer__pool.html#cc6344c000755eed939feb53dab6b474">max_buffer_size</a>) {
<a name="l00189"></a>00189         <span class="comment">// this buffer's size is out of date.  throw it away</span>
<a name="l00190"></a>00190         <span class="keyword">delete</span> [] q;
<a name="l00191"></a>00191       } <span class="keywordflow">else</span> {
<a name="l00192"></a>00192         <span class="comment">// push a buffer into the pool if it has the right size</span>
<a name="l00193"></a>00193         *((<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> **)(q + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>))) = <a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a>;
<a name="l00194"></a>00194         <a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a> = q;
<a name="l00195"></a>00195       }
<a name="l00196"></a>00196     }
<a name="l00197"></a>00197 
<a name="l00198"></a><a class="code" href="classtlm_1_1tlm__buffer__pool.html#eb2e4f1f651bf1644cd37b2960d9e39a">00198</a>     <span class="keywordtype">int</span> <a class="code" href="classtlm_1_1tlm__buffer__pool.html#eb2e4f1f651bf1644cd37b2960d9e39a">get_pool_size</a>() {
<a name="l00199"></a>00199       <span class="keywordtype">int</span> s = 0;
<a name="l00200"></a>00200       <span class="keywordflow">for</span>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *p = <a class="code" href="classtlm_1_1tlm__buffer__pool.html#849e90980ba72d8ffff9d9ffedc3a418">pool_head</a>; p != 0; p = *((<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> **)(p + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>))), s++) {}
<a name="l00201"></a>00201       <span class="keywordflow">return</span> s;
<a name="l00202"></a>00202     }
<a name="l00203"></a>00203 
<a name="l00204"></a><a class="code" href="classtlm_1_1tlm__buffer__pool.html#7ea706dedab51d6a14105402320ee9e5">00204</a>     <span class="keywordtype">int</span> <a class="code" href="classtlm_1_1tlm__buffer__pool.html#7ea706dedab51d6a14105402320ee9e5">get_buffer_size</a>() {<span class="keywordflow">return</span> <a class="code" href="classtlm_1_1tlm__buffer__pool.html#cc6344c000755eed939feb53dab6b474">max_buffer_size</a>;}
<a name="l00205"></a>00205 };
<a name="l00206"></a>00206 
<a name="l00207"></a><a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">00207</a> <span class="keyword">static</span> <a class="code" href="classtlm_1_1tlm__buffer__pool.html">tlm_buffer_pool</a> <a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>;
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="comment">// an extension to keep the information needed for reconversion of response</span>
<a name="l00210"></a><a class="code" href="classtlm_1_1tlm__endian__context.html">00210</a> <span class="keyword">class </span><a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> : <span class="keyword">public</span> <a class="code" href="classtlm_1_1tlm__extension.html">tlm_extension</a>&lt;tlm_endian_context&gt; {
<a name="l00211"></a>00211   <span class="keyword">public</span>:
<a name="l00212"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">00212</a>     sc_dt::uint64 <a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a>;     <span class="comment">// used by generic, word</span>
<a name="l00213"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#4b592ed6192127e7f2df6c810bbf1499">00213</a>     sc_dt::uint64 <a class="code" href="classtlm_1_1tlm__endian__context.html#4b592ed6192127e7f2df6c810bbf1499">new_address</a>;     <span class="comment">// used by generic</span>
<a name="l00214"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">00214</a>     <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>;     <span class="comment">// used by generic, word, aligned</span>
<a name="l00215"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#e4a357d465b80c6c6b049e48a736d34b">00215</a>     <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *<a class="code" href="classtlm_1_1tlm__endian__context.html#e4a357d465b80c6c6b049e48a736d34b">byte_enable</a>;  <span class="comment">// used by word</span>
<a name="l00216"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#caa2d690d4f526cbf6b39575033d717e">00216</a>     <span class="keywordtype">int</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#caa2d690d4f526cbf6b39575033d717e">length</a>;         <span class="comment">// used by generic, word</span>
<a name="l00217"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#d43407778698362ee2f0b92b9b43394a">00217</a>     <span class="keywordtype">int</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#d43407778698362ee2f0b92b9b43394a">stream_width</a>;   <span class="comment">// used by generic</span>
<a name="l00218"></a>00218 
<a name="l00219"></a>00219     <span class="comment">// used by common entry point on response</span>
<a name="l00220"></a>00220     void (*<a class="code" href="classtlm_1_1tlm__endian__context.html#d6c5b6fb7e74f050d115825408688dab">from_f</a>)(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a>);
<a name="l00221"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">00221</a>     <span class="keywordtype">int</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a>;
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="comment">// required for extension management</span>
<a name="l00224"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#9cbad660fb75aef9f1f8cacc7104175c">00224</a>     <a class="code" href="classtlm_1_1tlm__extension__base.html">tlm_extension_base</a>* <a class="code" href="classtlm_1_1tlm__endian__context.html#9cbad660fb75aef9f1f8cacc7104175c">clone</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> 0;}
<a name="l00225"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#260582657c6ebcd9f650d5df38242c7b">00225</a>     <span class="keywordtype">void</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#260582657c6ebcd9f650d5df38242c7b">free</a>() {<span class="keyword">delete</span> <span class="keyword">this</span>;}
<a name="l00226"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#3ae93523f40ea5aa42e29992a4ef2ac0">00226</a>     <span class="keywordtype">void</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#3ae93523f40ea5aa42e29992a4ef2ac0">copy_from</a>(<a class="code" href="classtlm_1_1tlm__extension__base.html">tlm_extension_base</a> <span class="keyword">const</span> &amp;) {<span class="keywordflow">return</span>;}
<a name="l00227"></a>00227 };
<a name="l00228"></a>00228 <span class="comment">// Assumptions about transaction contexts:</span>
<a name="l00229"></a>00229 <span class="comment">// 1) only the address attribute of a transaction</span>
<a name="l00230"></a>00230 <span class="comment">// is mutable.  all other attributes are unchanged from the request to</span>
<a name="l00231"></a>00231 <span class="comment">// response side conversion.</span>
<a name="l00232"></a>00232 <span class="comment">// 2) the conversion functions in this file do not respect the mutability</span>
<a name="l00233"></a>00233 <span class="comment">// rules and do not put the transaction back into its original state after</span>
<a name="l00234"></a>00234 <span class="comment">// completion.  so if the initiator has any cleaning up to do (eg of byte</span>
<a name="l00235"></a>00235 <span class="comment">// enable buffers), it needs to store its own context.  the transaction</span>
<a name="l00236"></a>00236 <span class="comment">// returned to the initiator may contain pointers to data and byte enable</span>
<a name="l00237"></a>00237 <span class="comment">// that can/must not be deleted.</span>
<a name="l00238"></a>00238 <span class="comment">// 3) the conversion functions in this file use an extension to store</span>
<a name="l00239"></a>00239 <span class="comment">// context information.  they do not remove this extension.  the initiator</span>
<a name="l00240"></a>00240 <span class="comment">// should not remove it unless it deletes the generic payload</span>
<a name="l00241"></a>00241 <span class="comment">// object.</span>
<a name="l00242"></a>00242 
<a name="l00243"></a><a class="code" href="namespacetlm.html#3d28c3714f7375334465f92755ed3e36">00243</a> <span class="keyword">inline</span> <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *<a class="code" href="namespacetlm.html#3d28c3714f7375334465f92755ed3e36">establish_context</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn) {
<a name="l00244"></a>00244   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#57e1f088841057cd1c2717701c240396">get_extension</a>&lt;<a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a>&gt;();
<a name="l00245"></a>00245   <span class="keywordflow">if</span>(tc == 0) {
<a name="l00246"></a>00246     tc = <span class="keyword">new</span> <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a>;
<a name="l00247"></a>00247     txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#736d6fe355b64be5280ba32386566163">set_extension</a>(tc);
<a name="l00248"></a>00248   }
<a name="l00249"></a>00249   <span class="keywordflow">return</span> tc;
<a name="l00250"></a>00250 }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="comment">// a set of constants for efficient filling of byte enables</span>
<a name="l00253"></a><a class="code" href="classtlm_1_1tlm__bool.html">00253</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; <span class="keyword">class </span><a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool</a> {
<a name="l00254"></a>00254   <span class="keyword">public</span>:
<a name="l00255"></a><a class="code" href="classtlm_1_1tlm__bool.html#4d94e18943c3348ffc1a63d42dc7c05f">00255</a>     <span class="keyword">static</span> D <a class="code" href="classtlm_1_1tlm__bool.html#4d94e18943c3348ffc1a63d42dc7c05f">TLM_TRUE</a>;
<a name="l00256"></a><a class="code" href="classtlm_1_1tlm__bool.html#05e9260a8b590567d128501634a3c1f9">00256</a>     <span class="keyword">static</span> D <a class="code" href="classtlm_1_1tlm__bool.html#05e9260a8b590567d128501634a3c1f9">TLM_FALSE</a>;
<a name="l00257"></a><a class="code" href="classtlm_1_1tlm__bool.html#09a7ec73e84adb2c54878081e61e3799">00257</a>     <span class="keyword">static</span> D <a class="code" href="classtlm_1_1tlm__bool.html#09a7ec73e84adb2c54878081e61e3799">make_uchar_array</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> c) {
<a name="l00258"></a>00258       D d;
<a name="l00259"></a>00259       <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *tmp = (<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)(&amp;d);
<a name="l00260"></a>00260       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<span class="keyword">sizeof</span>(D); i++) tmp[i] = c;
<a name="l00261"></a>00261       <span class="keywordflow">return</span> d;
<a name="l00262"></a>00262     }
<a name="l00263"></a>00263     <span class="comment">// also provides an syntax-efficient tester, using a</span>
<a name="l00264"></a>00264     <span class="comment">// copy constuctor and an implicit cast to boolean</span>
<a name="l00265"></a><a class="code" href="classtlm_1_1tlm__bool.html#9824e7f98684f1894b3db42108be58ef">00265</a>     <a class="code" href="classtlm_1_1tlm__bool.html#9824e7f98684f1894b3db42108be58ef">tlm_bool</a>(D &amp;d) : <a class="code" href="classtlm_1_1tlm__bool.html#e9862c124610a5d8e01834ce953d5aef">b</a>(*((<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>*)&amp;d) != <a class="code" href="tlm__gp_8h.html#ee6c671fa7a49f01da4a966f33067175">TLM_BYTE_DISABLED</a>) {}
<a name="l00266"></a><a class="code" href="classtlm_1_1tlm__bool.html#c2c0edb8930df836dd5dc6803b571629">00266</a>     <a class="code" href="classtlm_1_1tlm__bool.html#c2c0edb8930df836dd5dc6803b571629">operator bool</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <a class="code" href="classtlm_1_1tlm__bool.html#e9862c124610a5d8e01834ce953d5aef">b</a>;}
<a name="l00267"></a>00267   <span class="keyword">private</span>:
<a name="l00268"></a><a class="code" href="classtlm_1_1tlm__bool.html#e9862c124610a5d8e01834ce953d5aef">00268</a>     <span class="keywordtype">bool</span> <a class="code" href="classtlm_1_1tlm__bool.html#e9862c124610a5d8e01834ce953d5aef">b</a>;
<a name="l00269"></a>00269 };
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; D <a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool&lt;D&gt;::TLM_TRUE</a> = <a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool&lt;D&gt;::make_uchar_array</a>(<a class="code" href="tlm__gp_8h.html#f8d2c3eb34ebd54e62bb2016614a827f">TLM_BYTE_ENABLED</a>);
<a name="l00272"></a>00272 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; D <a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool&lt;D&gt;::TLM_FALSE</a> = <a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool&lt;D&gt;::make_uchar_array</a>(<a class="code" href="tlm__gp_8h.html#ee6c671fa7a49f01da4a966f33067175">TLM_BYTE_DISABLED</a>);
<a name="l00273"></a>00273 
<a name="l00275"></a>00275 <span class="comment">// function set (0): Utilities</span>
<a name="l00276"></a><a class="code" href="namespacetlm.html#00c757c3a05f6f752c3517548d3d9bfc">00276</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#00c757c3a05f6f752c3517548d3d9bfc">copy_db0</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00277"></a>00277   *dest1 = *src1;
<a name="l00278"></a>00278   *dest2 = *src2;
<a name="l00279"></a>00279 }
<a name="l00280"></a>00280 
<a name="l00281"></a><a class="code" href="namespacetlm.html#fb865af12e7e2ef0312c50d4cb6d292a">00281</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#fb865af12e7e2ef0312c50d4cb6d292a">copy_dbtrue0</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00282"></a>00282   *dest1 = *src1;
<a name="l00283"></a>00283   *dest2 = <a class="code" href="tlm__gp_8h.html#f8d2c3eb34ebd54e62bb2016614a827f">TLM_BYTE_ENABLED</a>;
<a name="l00284"></a>00284 }
<a name="l00285"></a>00285 
<a name="l00286"></a><a class="code" href="namespacetlm.html#9b19018aacff8562c49b3b6b148847af">00286</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#9b19018aacff8562c49b3b6b148847af">copy_btrue0</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00287"></a>00287   *dest2 = <a class="code" href="tlm__gp_8h.html#f8d2c3eb34ebd54e62bb2016614a827f">TLM_BYTE_ENABLED</a>;
<a name="l00288"></a>00288 }
<a name="l00289"></a>00289 
<a name="l00290"></a><a class="code" href="namespacetlm.html#0c70f2866a851446adb12550d9c44fa5">00290</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#0c70f2866a851446adb12550d9c44fa5">copy_b0</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00291"></a>00291   *dest2 = *src2;
<a name="l00292"></a>00292 }
<a name="l00293"></a>00293 
<a name="l00294"></a><a class="code" href="namespacetlm.html#9daf63e27286c5e92fe8a614173323a9">00294</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#9daf63e27286c5e92fe8a614173323a9">copy_dbyb0</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00295"></a>00295   <span class="keywordflow">if</span>(*dest2 == <a class="code" href="tlm__gp_8h.html#f8d2c3eb34ebd54e62bb2016614a827f">TLM_BYTE_ENABLED</a>) *src1 = *dest1;
<a name="l00296"></a>00296 }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="keyword">template</span>&lt;<span class="keyword">class </span>D,
<a name="l00300"></a>00300   <span class="keywordtype">void</span> COPY(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *he_d, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *he_b, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *ie_d, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *ie_b)&gt;
<a name="l00301"></a><a class="code" href="namespacetlm.html#05d4d192746ca202086606dec7bacb82">00301</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#05d4d192746ca202086606dec7bacb82">loop_generic0</a>(<span class="keywordtype">int</span> new_len, <span class="keywordtype">int</span> new_stream_width,
<a name="l00302"></a>00302   <span class="keywordtype">int</span> orig_stream_width, <span class="keywordtype">int</span> sizeof_databus,
<a name="l00303"></a>00303   sc_dt::uint64 orig_start_address, sc_dt::uint64 new_start_address, <span class="keywordtype">int</span> be_length,
<a name="l00304"></a>00304   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *ie_data, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *ie_be, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *he_data, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *he_be) {
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> orig_sword = 0, new_sword = 0; new_sword &lt; new_len;
<a name="l00307"></a>00307       new_sword += new_stream_width, orig_sword += orig_stream_width) {
<a name="l00308"></a>00308 
<a name="l00309"></a>00309     sc_dt::uint64 ie_addr = orig_start_address;
<a name="l00310"></a>00310     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> orig_dword = orig_sword;
<a name="l00311"></a>00311       orig_dword &lt; orig_sword + orig_stream_width; orig_dword += <span class="keyword">sizeof</span>(D)) {
<a name="l00312"></a>00312 
<a name="l00313"></a>00313       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> curr_byte = orig_dword + <span class="keyword">sizeof</span>(D) - 1;
<a name="l00314"></a>00314           curr_byte &gt;= orig_dword; curr_byte--) {
<a name="l00315"></a>00315 
<a name="l00316"></a>00316         <span class="keywordtype">int</span> he_index = ((ie_addr++) ^ (sizeof_databus - 1))
<a name="l00317"></a>00317           - new_start_address + new_sword;
<a name="l00318"></a>00318         COPY(ie_data+curr_byte, ie_be+(curr_byte % be_length),
<a name="l00319"></a>00319              he_data+he_index, he_be+he_index);
<a name="l00320"></a>00320       }
<a name="l00321"></a>00321     }
<a name="l00322"></a>00322   }
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 
<a name="l00327"></a>00327 <span class="comment">// function set (0): Response</span>
<a name="l00328"></a>00328 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00329"></a><a class="code" href="namespacetlm.html#5be70eaa5ff8579d2e411208f58a6e48">00329</a> <a class="code" href="namespacetlm.html#5be70eaa5ff8579d2e411208f58a6e48">tlm_from_hostendian_generic</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00330"></a>00330   <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#a99b26718e52fd5a49ab8475b44b8dac">is_read</a>()) {
<a name="l00331"></a>00331     <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = txn-&gt;template get_extension&lt;tlm_endian_context&gt;();
<a name="l00332"></a>00332 
<a name="l00333"></a>00333     loop_generic0&lt;DATAWORD, &amp;copy_dbyb0&gt;(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>(),
<a name="l00334"></a>00334       txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8cc2025a351f5fa8cf3e91a03a089a81">get_streaming_width</a>(), tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d43407778698362ee2f0b92b9b43394a">stream_width</a>, sizeof_databus, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a>,
<a name="l00335"></a>00335       tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#4b592ed6192127e7f2df6c810bbf1499">new_address</a>, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>(), tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>, 0, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(),
<a name="l00336"></a>00336       txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00337"></a>00337   }
<a name="l00338"></a>00338 
<a name="l00339"></a>00339   <a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>.<a class="code" href="classtlm_1_1tlm__buffer__pool.html#906b255f8acff3bfaf550c864d9ee05a">return_buffer</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00340"></a>00340   <a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>.<a class="code" href="classtlm_1_1tlm__buffer__pool.html#906b255f8acff3bfaf550c864d9ee05a">return_buffer</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>());
<a name="l00341"></a>00341 }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 
<a name="l00345"></a>00345 <span class="comment">// function set (0): Request</span>
<a name="l00346"></a>00346 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00347"></a><a class="code" href="namespacetlm.html#ac25bb86d1f480fd3155655502929131">00347</a> <a class="code" href="namespacetlm.html#ac25bb86d1f480fd3155655502929131">tlm_to_hostendian_generic</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00348"></a>00348   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = <a class="code" href="namespacetlm.html#3d28c3714f7375334465f92755ed3e36">establish_context</a>(txn);
<a name="l00349"></a>00349   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d6c5b6fb7e74f050d115825408688dab">from_f</a> = &amp;(tlm_from_hostendian_generic&lt;DATAWORD&gt;);
<a name="l00350"></a>00350   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a> = sizeof_databus;
<a name="l00351"></a>00351 
<a name="l00352"></a>00352   <span class="comment">// calculate new size:  nr stream words multiplied by big enough stream width</span>
<a name="l00353"></a>00353   <span class="keywordtype">int</span> s_width = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8cc2025a351f5fa8cf3e91a03a089a81">get_streaming_width</a>();
<a name="l00354"></a>00354   <span class="keywordtype">int</span> length = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>();
<a name="l00355"></a>00355   <span class="keywordflow">if</span>(s_width &gt;= length) s_width = length;
<a name="l00356"></a>00356   <span class="keywordtype">int</span> nr_stream_words = length/s_width;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   <span class="comment">// find out in which bus word the stream word starts and ends</span>
<a name="l00359"></a>00359   sc_dt::uint64 new_address = (txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>() &amp; ~(sizeof_databus - 1));
<a name="l00360"></a>00360   sc_dt::uint64 end_address = ((txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>() + s_width - 1)
<a name="l00361"></a>00361     &amp; ~(sizeof_databus - 1));
<a name="l00362"></a>00362 
<a name="l00363"></a>00363   <span class="keywordtype">int</span> new_stream_width = end_address - new_address + sizeof_databus;
<a name="l00364"></a>00364   <span class="keywordtype">int</span> new_length = new_stream_width * nr_stream_words;
<a name="l00365"></a>00365 
<a name="l00366"></a>00366   <span class="comment">// store context</span>
<a name="l00367"></a>00367   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a> = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>();
<a name="l00368"></a>00368   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a> = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>();
<a name="l00369"></a>00369   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#4b592ed6192127e7f2df6c810bbf1499">new_address</a> = new_address;
<a name="l00370"></a>00370   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d43407778698362ee2f0b92b9b43394a">stream_width</a> = s_width;
<a name="l00371"></a>00371   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *orig_be = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>();
<a name="l00372"></a>00372   <span class="keywordtype">int</span> orig_be_length = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#76711646a3572d111dc6d80769e55158">get_byte_enable_length</a>();
<a name="l00373"></a>00373 
<a name="l00374"></a>00374   <span class="comment">// create data and byte-enable buffers</span>
<a name="l00375"></a>00375   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#486d7746584d058f148f6b3d6aab55c4">set_address</a>(new_address);
<a name="l00376"></a>00376   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#03a1359e212624b834b64ac4b36a82ba">set_data_ptr</a>(<a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>.<a class="code" href="classtlm_1_1tlm__buffer__pool.html#4f26fed0eba7796a462b4e13258488cc">get_a_buffer</a>(new_length));
<a name="l00377"></a>00377   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#ef1f7d2a2d743aaa304a85d361e880db">set_byte_enable_ptr</a>(<a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>.<a class="code" href="classtlm_1_1tlm__buffer__pool.html#4f26fed0eba7796a462b4e13258488cc">get_a_buffer</a>(new_length));
<a name="l00378"></a>00378   memset(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>(), <a class="code" href="tlm__gp_8h.html#ee6c671fa7a49f01da4a966f33067175">TLM_BYTE_DISABLED</a>, new_length);
<a name="l00379"></a>00379   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#bdd0e57c84918a6a1796248e577979f7">set_streaming_width</a>(new_stream_width);
<a name="l00380"></a>00380   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8bb2743225851e7d2e8d5c3f0213f379">set_data_length</a>(new_length);
<a name="l00381"></a>00381   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#465e5b08194660aa0b66d4e8219fa887">set_byte_enable_length</a>(new_length);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383   <span class="comment">// copy data and/or byte enables</span>
<a name="l00384"></a>00384   <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#234bd44edb3ccb706b7ba030c3a2200d">is_write</a>()) {
<a name="l00385"></a>00385     <span class="keywordflow">if</span>(orig_be == 0) {
<a name="l00386"></a>00386       loop_generic0&lt;DATAWORD, &amp;copy_dbtrue0&gt;(new_length,
<a name="l00387"></a>00387         new_stream_width, s_width, sizeof_databus, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a>,
<a name="l00388"></a>00388         new_address, new_length, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>, 0, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(),
<a name="l00389"></a>00389         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00390"></a>00390     } <span class="keywordflow">else</span> {
<a name="l00391"></a>00391       loop_generic0&lt;DATAWORD, &amp;copy_db0&gt;(new_length,
<a name="l00392"></a>00392         new_stream_width, s_width, sizeof_databus, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a>,
<a name="l00393"></a>00393         new_address, orig_be_length, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>, orig_be, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(),
<a name="l00394"></a>00394         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00395"></a>00395     }
<a name="l00396"></a>00396   } <span class="keywordflow">else</span> { <span class="comment">// read transaction</span>
<a name="l00397"></a>00397     <span class="keywordflow">if</span>(orig_be == 0) {
<a name="l00398"></a>00398       loop_generic0&lt;DATAWORD, &amp;copy_btrue0&gt;(new_length,
<a name="l00399"></a>00399         new_stream_width, s_width, sizeof_databus, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a>,
<a name="l00400"></a>00400         new_address, new_length, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>, 0, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(),
<a name="l00401"></a>00401         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00402"></a>00402     } <span class="keywordflow">else</span> {
<a name="l00403"></a>00403       loop_generic0&lt;DATAWORD, &amp;copy_b0&gt;(new_length,
<a name="l00404"></a>00404         new_stream_width, s_width, sizeof_databus, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a>,
<a name="l00405"></a>00405         new_address, orig_be_length, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>, orig_be, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(),
<a name="l00406"></a>00406         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00407"></a>00407     }
<a name="l00408"></a>00408   }
<a name="l00409"></a>00409 }
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 
<a name="l00414"></a>00414 <span class="comment">// function set (1): Utilities</span>
<a name="l00415"></a>00415 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00416"></a><a class="code" href="namespacetlm.html#84cdb571cfc8732f851414f7d9bcd907">00416</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#84cdb571cfc8732f851414f7d9bcd907">copy_d1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00417"></a>00417   *((D *)dest1) = *((D *)src1);
<a name="l00418"></a>00418   *((D *)dest2) = <a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool&lt;D&gt;::TLM_TRUE</a>;
<a name="l00419"></a>00419 }
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00422"></a><a class="code" href="namespacetlm.html#c1f531b30e3457e23cf7390af89d177c">00422</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#c1f531b30e3457e23cf7390af89d177c">copy_db1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00423"></a>00423   *((D *)dest1) = *((D *)src1);
<a name="l00424"></a>00424   *((D *)dest2) = *((D *)src2);
<a name="l00425"></a>00425 }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00428"></a><a class="code" href="namespacetlm.html#62d5cdda8e34c8d294c8bddfad2b430d">00428</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#62d5cdda8e34c8d294c8bddfad2b430d">true_b1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00429"></a>00429   *((D *)dest2) = <a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool&lt;D&gt;::TLM_TRUE</a>;
<a name="l00430"></a>00430 }
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00433"></a><a class="code" href="namespacetlm.html#ce6bc65e046b4e4462fee34350600937">00433</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#ce6bc65e046b4e4462fee34350600937">copy_b1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00434"></a>00434   *((D *)dest2) = *((D *)src2);
<a name="l00435"></a>00435 }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00438"></a><a class="code" href="namespacetlm.html#857724d110a186851542ef0ed25bc988">00438</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#857724d110a186851542ef0ed25bc988">copy_dbyb1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00439"></a>00439   <span class="keywordflow">if</span>(*src2 != <a class="code" href="tlm__gp_8h.html#ee6c671fa7a49f01da4a966f33067175">TLM_BYTE_DISABLED</a>)  *((D *)src1) = *((D *)dest1);
<a name="l00440"></a>00440 }
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00443"></a><a class="code" href="namespacetlm.html#31284a38d814a73fadab6e4b7fd3f344">00443</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#31284a38d814a73fadab6e4b7fd3f344">copy_dbytrue1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00444"></a>00444   *((D *)src1) = *((D *)dest1);
<a name="l00445"></a>00445 }
<a name="l00446"></a>00446 
<a name="l00447"></a><a class="code" href="namespacetlm.html#bb2f8a63e8e66eb796f69f99b31ddd2f">00447</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#bb2f8a63e8e66eb796f69f99b31ddd2f">false_b1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1) {
<a name="l00448"></a>00448   *((D *)dest1) = <a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool&lt;D&gt;::TLM_FALSE</a>;
<a name="l00449"></a>00449 }
<a name="l00450"></a>00450 
<a name="l00451"></a><a class="code" href="namespacetlm.html#51f3cb6b05cbcb2a0f3fec8fa61bf620">00451</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#51f3cb6b05cbcb2a0f3fec8fa61bf620">no_b1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1) {
<a name="l00452"></a>00452 }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="keyword">template</span>&lt;<span class="keyword">class </span>D,
<a name="l00455"></a>00455          <span class="keywordtype">void</span> COPY(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2),
<a name="l00456"></a>00456          <span class="keywordtype">void</span> COPYuchar(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2),
<a name="l00457"></a>00457          <span class="keywordtype">void</span> FILLFALSE(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1), <span class="keywordtype">void</span> FILLFALSEuchar(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1)&gt;
<a name="l00458"></a><a class="code" href="namespacetlm.html#2c4671fae3a52f0d9250c56535776cce">00458</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespacetlm.html#2c4671fae3a52f0d9250c56535776cce">loop_word1</a>(
<a name="l00459"></a>00459   <span class="keywordtype">int</span> bytes_left, <span class="keywordtype">int</span> len0, <span class="keywordtype">int</span> lenN, <span class="keywordtype">int</span> sizeof_databus,
<a name="l00460"></a>00460   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *start, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *end, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *bsrc, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *bdest) {
<a name="l00461"></a>00461   <span class="keywordtype">int</span> d2b_src = bsrc - src;
<a name="l00462"></a>00462   <span class="keywordtype">int</span> d2b_dest = bdest - dest;
<a name="l00463"></a>00463   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *original_dest = dest;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465   <span class="keywordflow">while</span>(<span class="keyword">true</span>) {
<a name="l00466"></a>00466     <span class="comment">// len0 bytes at start of a bus word</span>
<a name="l00467"></a>00467     <span class="keywordflow">if</span>((src &gt;= start) &amp;&amp; (src &lt; end)) {
<a name="l00468"></a>00468       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;len0; i++) {
<a name="l00469"></a>00469         COPYuchar(src, src+d2b_src, dest, dest+d2b_dest);
<a name="l00470"></a>00470         src++;
<a name="l00471"></a>00471         dest++;
<a name="l00472"></a>00472       }
<a name="l00473"></a>00473       bytes_left -= len0;
<a name="l00474"></a>00474       <span class="keywordflow">if</span>(bytes_left &lt;= 0) <span class="keywordflow">return</span> int(dest - original_dest);
<a name="l00475"></a>00475     } <span class="keywordflow">else</span> {
<a name="l00476"></a>00476       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;len0; i++) {
<a name="l00477"></a>00477         FILLFALSEuchar(dest+d2b_dest);
<a name="l00478"></a>00478         src++;
<a name="l00479"></a>00479         dest++;
<a name="l00480"></a>00480       }
<a name="l00481"></a>00481     }
<a name="l00482"></a>00482     src -= 2 * <span class="keyword">sizeof</span>(D);
<a name="l00483"></a>00483 
<a name="l00484"></a>00484     <span class="comment">// sequence of full data word fragments</span>
<a name="l00485"></a>00485     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1; i&lt;sizeof_databus/<span class="keyword">sizeof</span>(D); i++) {
<a name="l00486"></a>00486       <span class="keywordflow">if</span>((src &gt;= start) &amp;&amp; (src &lt; end)) {
<a name="l00487"></a>00487         COPY(src, src+d2b_src, dest, dest+d2b_dest);
<a name="l00488"></a>00488         bytes_left -= <span class="keyword">sizeof</span>(D);
<a name="l00489"></a>00489       } <span class="keywordflow">else</span> {
<a name="l00490"></a>00490         FILLFALSE(dest+d2b_dest);
<a name="l00491"></a>00491       }
<a name="l00492"></a>00492       dest += <span class="keyword">sizeof</span>(D);
<a name="l00493"></a>00493       <span class="keywordflow">if</span>(bytes_left &lt;= 0) <span class="keywordflow">return</span> int(dest - original_dest);
<a name="l00494"></a>00494       src -= <span class="keyword">sizeof</span>(D);
<a name="l00495"></a>00495     }
<a name="l00496"></a>00496 
<a name="l00497"></a>00497     <span class="comment">// lenN bytes at end of bus word</span>
<a name="l00498"></a>00498     <span class="keywordflow">if</span>((src &gt;= start) &amp;&amp; (src &lt; end)) {
<a name="l00499"></a>00499       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;lenN; i++) {
<a name="l00500"></a>00500         COPYuchar(src, src+d2b_src, dest, dest+d2b_dest);
<a name="l00501"></a>00501         src++;
<a name="l00502"></a>00502         dest++;
<a name="l00503"></a>00503       }
<a name="l00504"></a>00504       bytes_left -= lenN;
<a name="l00505"></a>00505       <span class="keywordflow">if</span>(bytes_left &lt;= 0) <span class="keywordflow">return</span> int(dest - original_dest);
<a name="l00506"></a>00506     } <span class="keywordflow">else</span> {
<a name="l00507"></a>00507       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;lenN; i++) {
<a name="l00508"></a>00508         FILLFALSEuchar(dest+d2b_dest);
<a name="l00509"></a>00509         src++;
<a name="l00510"></a>00510         dest++;
<a name="l00511"></a>00511       }
<a name="l00512"></a>00512     }
<a name="l00513"></a>00513     src += 2 * sizeof_databus;
<a name="l00514"></a>00514   }
<a name="l00515"></a>00515 }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 
<a name="l00519"></a>00519 <span class="comment">// function set (1): Response</span>
<a name="l00520"></a>00520 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00521"></a><a class="code" href="namespacetlm.html#0c2303006c0d0a9434b765387180f6c2">00521</a> <a class="code" href="namespacetlm.html#0c2303006c0d0a9434b765387180f6c2">tlm_from_hostendian_word</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00522"></a>00522   <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#a99b26718e52fd5a49ab8475b44b8dac">is_read</a>()) {
<a name="l00523"></a>00523     <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = txn-&gt;template get_extension&lt;tlm_endian_context&gt;();
<a name="l00524"></a>00524 
<a name="l00525"></a>00525     sc_dt::uint64 b_mask = sizeof_databus - 1;
<a name="l00526"></a>00526     <span class="keywordtype">int</span> d_mask = <span class="keyword">sizeof</span>(DATAWORD) - 1;
<a name="l00527"></a>00527     <span class="keywordtype">int</span> a_offset = tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a> &amp; b_mask;
<a name="l00528"></a>00528     <span class="keywordtype">int</span> len0 = (sizeof_databus - a_offset) &amp; d_mask;
<a name="l00529"></a>00529     <span class="keywordtype">int</span> lenN = <span class="keyword">sizeof</span>(DATAWORD) - len0;
<a name="l00530"></a>00530     <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *d_start = tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>;
<a name="l00531"></a>00531     <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *d_end = tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#caa2d690d4f526cbf6b39575033d717e">length</a> + d_start;
<a name="l00532"></a>00532     <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *d = ((sizeof_databus - a_offset) &amp; ~d_mask) + lenN + d_start;
<a name="l00533"></a>00533 
<a name="l00534"></a>00534     <span class="comment">// iterate over transaction copying data qualified by byte-enables</span>
<a name="l00535"></a>00535     <span class="keywordflow">if</span>(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#e4a357d465b80c6c6b049e48a736d34b">byte_enable</a> == 0) {
<a name="l00536"></a>00536       loop_word1&lt;DATAWORD, &amp;copy_dbytrue1&lt;DATAWORD&gt;,
<a name="l00537"></a>00537         &amp;copy_dbytrue1&lt;uchar&gt;, &amp;no_b1&lt;DATAWORD&gt;, &amp;no_b1&lt;uchar&gt; &gt;(
<a name="l00538"></a>00538         tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#caa2d690d4f526cbf6b39575033d717e">length</a>, len0, lenN, sizeof_databus, d_start, d_end, d,
<a name="l00539"></a>00539         0, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(), 0);
<a name="l00540"></a>00540     } <span class="keywordflow">else</span> {
<a name="l00541"></a>00541       loop_word1&lt;DATAWORD, &amp;copy_dbyb1&lt;DATAWORD&gt;,
<a name="l00542"></a>00542         &amp;copy_dbyb1&lt;uchar&gt;, &amp;no_b1&lt;DATAWORD&gt;, &amp;no_b1&lt;uchar&gt; &gt;(
<a name="l00543"></a>00543         tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#caa2d690d4f526cbf6b39575033d717e">length</a>, len0, lenN, sizeof_databus, d_start, d_end, d,
<a name="l00544"></a>00544         tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#e4a357d465b80c6c6b049e48a736d34b">byte_enable</a> - d_start + d, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(), 0);
<a name="l00545"></a>00545     }
<a name="l00546"></a>00546   }
<a name="l00547"></a>00547   <a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>.<a class="code" href="classtlm_1_1tlm__buffer__pool.html#906b255f8acff3bfaf550c864d9ee05a">return_buffer</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00548"></a>00548   <a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>.<a class="code" href="classtlm_1_1tlm__buffer__pool.html#906b255f8acff3bfaf550c864d9ee05a">return_buffer</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>());
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 
<a name="l00553"></a>00553 <span class="comment">// function set (1): Request</span>
<a name="l00554"></a>00554 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00555"></a><a class="code" href="namespacetlm.html#35b6acc377c3fde9939342bf09d2a688">00555</a> <a class="code" href="namespacetlm.html#35b6acc377c3fde9939342bf09d2a688">tlm_to_hostendian_word</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00556"></a>00556   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = <a class="code" href="namespacetlm.html#3d28c3714f7375334465f92755ed3e36">establish_context</a>(txn);
<a name="l00557"></a>00557   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d6c5b6fb7e74f050d115825408688dab">from_f</a> = &amp;(tlm_from_hostendian_word&lt;DATAWORD&gt;);
<a name="l00558"></a>00558   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a> = sizeof_databus;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560   sc_dt::uint64 b_mask = sizeof_databus - 1;
<a name="l00561"></a>00561   <span class="keywordtype">int</span> d_mask = <span class="keyword">sizeof</span>(DATAWORD) - 1;
<a name="l00562"></a>00562   sc_dt::uint64 a_aligned = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>() &amp; ~b_mask;
<a name="l00563"></a>00563   <span class="keywordtype">int</span> a_offset = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>() &amp; b_mask;
<a name="l00564"></a>00564   <span class="keywordtype">int</span> len0 = (sizeof_databus - a_offset) &amp; d_mask;
<a name="l00565"></a>00565   <span class="keywordtype">int</span> lenN = <span class="keyword">sizeof</span>(DATAWORD) - len0;
<a name="l00566"></a>00566   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *d_start = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>();
<a name="l00567"></a>00567   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *d_end = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>() + d_start;
<a name="l00568"></a>00568   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *d = ((sizeof_databus - a_offset) &amp; ~d_mask) + lenN + d_start;
<a name="l00569"></a>00569 
<a name="l00570"></a>00570   <span class="comment">// create new data and byte enable buffers</span>
<a name="l00571"></a>00571   <span class="keywordtype">int</span> long_enough = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>() + 2 * sizeof_databus;
<a name="l00572"></a>00572   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *new_data = <a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>.<a class="code" href="classtlm_1_1tlm__buffer__pool.html#4f26fed0eba7796a462b4e13258488cc">get_a_buffer</a>(long_enough);
<a name="l00573"></a>00573   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *new_be = <a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>.<a class="code" href="classtlm_1_1tlm__buffer__pool.html#4f26fed0eba7796a462b4e13258488cc">get_a_buffer</a>(long_enough);
<a name="l00574"></a>00574 
<a name="l00575"></a>00575   <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#a99b26718e52fd5a49ab8475b44b8dac">is_read</a>()) {
<a name="l00576"></a>00576     tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a> = d_start;
<a name="l00577"></a>00577     tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a> = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>();
<a name="l00578"></a>00578     tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#e4a357d465b80c6c6b049e48a736d34b">byte_enable</a> = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>();
<a name="l00579"></a>00579     tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#caa2d690d4f526cbf6b39575033d717e">length</a> = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>();
<a name="l00580"></a>00580     <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>() == 0) {
<a name="l00581"></a>00581       <span class="comment">// iterate over transaction creating new byte enables from all-true</span>
<a name="l00582"></a>00582       txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8bb2743225851e7d2e8d5c3f0213f379">set_data_length</a>(<a class="code" href="namespacetlm.html#2c4671fae3a52f0d9250c56535776cce">loop_word1</a>&lt;DATAWORD, &amp;true_b1&lt;DATAWORD&gt;,
<a name="l00583"></a>00583         &amp;true_b1&lt;uchar&gt;, &amp;false_b1&lt;DATAWORD&gt;, &amp;false_b1&lt;uchar&gt; &gt;(
<a name="l00584"></a>00584         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>(), len0, lenN, sizeof_databus,
<a name="l00585"></a>00585         d_start, d_end, d, 0, new_data, new_be));
<a name="l00586"></a>00586     } <span class="keywordflow">else</span> {
<a name="l00587"></a>00587       <span class="comment">// iterate over transaction copying byte enables</span>
<a name="l00588"></a>00588       txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8bb2743225851e7d2e8d5c3f0213f379">set_data_length</a>(<a class="code" href="namespacetlm.html#2c4671fae3a52f0d9250c56535776cce">loop_word1</a>&lt;DATAWORD, &amp;copy_b1&lt;DATAWORD&gt;,
<a name="l00589"></a>00589         &amp;copy_b1&lt;uchar&gt;, &amp;false_b1&lt;DATAWORD&gt;, &amp;false_b1&lt;uchar&gt; &gt;(
<a name="l00590"></a>00590         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>(), len0, lenN, sizeof_databus, d_start, d_end,
<a name="l00591"></a>00591         d, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>() - d_start + d, new_data, new_be));
<a name="l00592"></a>00592     }
<a name="l00593"></a>00593   } <span class="keywordflow">else</span> {
<a name="l00594"></a>00594     <span class="comment">// WRITE</span>
<a name="l00595"></a>00595     <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>() == 0) {
<a name="l00596"></a>00596       <span class="comment">// iterate over transaction copying data and creating new byte-enables</span>
<a name="l00597"></a>00597       txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8bb2743225851e7d2e8d5c3f0213f379">set_data_length</a>(<a class="code" href="namespacetlm.html#2c4671fae3a52f0d9250c56535776cce">loop_word1</a>&lt;DATAWORD, &amp;copy_d1&lt;DATAWORD&gt;,
<a name="l00598"></a>00598         &amp;copy_d1&lt;uchar&gt;, &amp;false_b1&lt;DATAWORD&gt;, &amp;false_b1&lt;uchar&gt; &gt;(
<a name="l00599"></a>00599         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>(), len0, lenN, sizeof_databus,
<a name="l00600"></a>00600         d_start, d_end, d, 0, new_data, new_be));
<a name="l00601"></a>00601     } <span class="keywordflow">else</span> {
<a name="l00602"></a>00602       <span class="comment">// iterate over transaction copying data and byte-enables</span>
<a name="l00603"></a>00603       txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8bb2743225851e7d2e8d5c3f0213f379">set_data_length</a>(<a class="code" href="namespacetlm.html#2c4671fae3a52f0d9250c56535776cce">loop_word1</a>&lt;DATAWORD, &amp;copy_db1&lt;DATAWORD&gt;,
<a name="l00604"></a>00604         &amp;copy_db1&lt;uchar&gt;, &amp;false_b1&lt;DATAWORD&gt;, &amp;false_b1&lt;uchar&gt; &gt;(
<a name="l00605"></a>00605         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>(), len0, lenN, sizeof_databus, d_start, d_end,
<a name="l00606"></a>00606         d, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>() - d_start + d, new_data, new_be));
<a name="l00607"></a>00607     }
<a name="l00608"></a>00608   }
<a name="l00609"></a>00609   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#465e5b08194660aa0b66d4e8219fa887">set_byte_enable_length</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>());
<a name="l00610"></a>00610   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#bdd0e57c84918a6a1796248e577979f7">set_streaming_width</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>());
<a name="l00611"></a>00611   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#03a1359e212624b834b64ac4b36a82ba">set_data_ptr</a>(new_data);
<a name="l00612"></a>00612   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#ef1f7d2a2d743aaa304a85d361e880db">set_byte_enable_ptr</a>(new_be);
<a name="l00613"></a>00613   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#486d7746584d058f148f6b3d6aab55c4">set_address</a>(a_aligned);
<a name="l00614"></a>00614 }
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 
<a name="l00619"></a>00619 <span class="comment">// function set (2): Utilities</span>
<a name="l00620"></a><a class="code" href="namespacetlm.html#5999c6d18647908c0e26d0f9904dc748">00620</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#5999c6d18647908c0e26d0f9904dc748">copy_d2</a>(D *src1, D *src2, D *dest1, D *dest2) {
<a name="l00621"></a>00621   *dest1 = *src1;
<a name="l00622"></a>00622 }
<a name="l00623"></a>00623 
<a name="l00624"></a><a class="code" href="namespacetlm.html#8cbc0c1ac45d4daae88569377c49b76e">00624</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#8cbc0c1ac45d4daae88569377c49b76e">copy_db2</a>(D *src1, D *src2, D *dest1, D *dest2) {
<a name="l00625"></a>00625   *dest1 = *src1;
<a name="l00626"></a>00626   *dest2 = *src2;
<a name="l00627"></a>00627 }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00630"></a><a class="code" href="namespacetlm.html#42e626507b6d547e498f97833c4c4a1c">00630</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#42e626507b6d547e498f97833c4c4a1c">copy_dbyb2</a>(D *src1, D *src2, D *dest1, D *dest2) {
<a name="l00631"></a>00631   <span class="keywordflow">if</span>(<a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool&lt;D&gt;</a>(*src2)) *dest1 = *src1;
<a name="l00632"></a>00632 }
<a name="l00633"></a>00633 
<a name="l00634"></a>00634 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D, <span class="keywordtype">void</span> COPY(D *src1, D *src2, D *dest1, D *dest2)&gt;
<a name="l00635"></a><a class="code" href="namespacetlm.html#8683423851f1e7bc2e4b4c7432e139c6">00635</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#8683423851f1e7bc2e4b4c7432e139c6">loop_aligned2</a>(D *src1, D *src2, D *dest1, D *dest2,
<a name="l00636"></a>00636     <span class="keywordtype">int</span> words, <span class="keywordtype">int</span> words_per_bus) {
<a name="l00637"></a>00637   <span class="keywordtype">int</span> src1to2 = int(src2) - int(src1);
<a name="l00638"></a>00638   <span class="keywordtype">int</span> dest1to2 = int(dest2) - int(dest1);
<a name="l00639"></a>00639 
<a name="l00640"></a>00640   D *done = src1 + words;
<a name="l00641"></a>00641   D *bus_start = src1;
<a name="l00642"></a>00642   src1 += words_per_bus - 1;
<a name="l00643"></a>00643 
<a name="l00644"></a>00644   <span class="keywordflow">while</span>(<span class="keyword">true</span>) {
<a name="l00645"></a>00645     COPY(src1, (D *)(<span class="keywordtype">int</span>(src1)+src1to2), dest1, (D *)(<span class="keywordtype">int</span>(dest1)+dest1to2));
<a name="l00646"></a>00646     dest1++;
<a name="l00647"></a>00647     <span class="keywordflow">if</span>((--src1) &lt; bus_start) {
<a name="l00648"></a>00648       bus_start += words_per_bus;
<a name="l00649"></a>00649       <span class="keywordflow">if</span>(bus_start == done) <span class="keywordflow">break</span>;
<a name="l00650"></a>00650       src1 = bus_start + words_per_bus - 1;
<a name="l00651"></a>00651     }
<a name="l00652"></a>00652   }
<a name="l00653"></a>00653 }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655 
<a name="l00657"></a>00657 <span class="comment">// function set (2): Response</span>
<a name="l00658"></a>00658 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00659"></a><a class="code" href="namespacetlm.html#90c3a9a3b2afd67bc8e174172e074e18">00659</a> <a class="code" href="namespacetlm.html#90c3a9a3b2afd67bc8e174172e074e18">tlm_from_hostendian_aligned</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00660"></a>00660   <span class="keywordtype">int</span> words_per_bus = sizeof_databus/<span class="keyword">sizeof</span>(DATAWORD);
<a name="l00661"></a>00661   <span class="keywordflow">if</span>(words_per_bus == 1) <span class="keywordflow">return</span>;
<a name="l00662"></a>00662   <span class="keywordtype">int</span> words = (txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>())/<span class="keyword">sizeof</span>(DATAWORD);
<a name="l00663"></a>00663 
<a name="l00664"></a>00664   <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>() == 0) {
<a name="l00665"></a>00665     <span class="comment">// no byte enables</span>
<a name="l00666"></a>00666     <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#a99b26718e52fd5a49ab8475b44b8dac">is_read</a>()) {
<a name="l00667"></a>00667       <span class="comment">// RD without byte enables.  Copy data to original buffer</span>
<a name="l00668"></a>00668       <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = txn-&gt;template get_extension&lt;tlm_endian_context&gt;();
<a name="l00669"></a>00669       loop_aligned2&lt;DATAWORD, &amp;copy_d2&lt;DATAWORD&gt; &gt;(
<a name="l00670"></a>00670         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>()),
<a name="l00671"></a>00671         0, (DATAWORD *)(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>), 0, words, words_per_bus);
<a name="l00672"></a>00672     }
<a name="l00673"></a>00673   } <span class="keywordflow">else</span> {
<a name="l00674"></a>00674     <span class="comment">// byte enables present</span>
<a name="l00675"></a>00675     <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#a99b26718e52fd5a49ab8475b44b8dac">is_read</a>()) {
<a name="l00676"></a>00676       <span class="comment">// RD with byte enables.  Copy data qualified by byte-enables</span>
<a name="l00677"></a>00677       <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = txn-&gt;template get_extension&lt;tlm_endian_context&gt;();
<a name="l00678"></a>00678       loop_aligned2&lt;DATAWORD, &amp;copy_dbyb2&lt;DATAWORD&gt; &gt;(
<a name="l00679"></a>00679         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>()),
<a name="l00680"></a>00680         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>()),
<a name="l00681"></a>00681         (DATAWORD *)(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>), 0, words, words_per_bus);
<a name="l00682"></a>00682     }
<a name="l00683"></a>00683     <a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>.<a class="code" href="classtlm_1_1tlm__buffer__pool.html#906b255f8acff3bfaf550c864d9ee05a">return_buffer</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00684"></a>00684   }
<a name="l00685"></a>00685   <span class="comment">// in all cases free the new data buffer</span>
<a name="l00686"></a>00686   <a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>.<a class="code" href="classtlm_1_1tlm__buffer__pool.html#906b255f8acff3bfaf550c864d9ee05a">return_buffer</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>());
<a name="l00687"></a>00687 }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 
<a name="l00691"></a>00691 <span class="comment">// function set (2): Request</span>
<a name="l00692"></a>00692 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00693"></a><a class="code" href="namespacetlm.html#a097d494385217cb589f046dc0adf62d">00693</a> <a class="code" href="namespacetlm.html#a097d494385217cb589f046dc0adf62d">tlm_to_hostendian_aligned</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00694"></a>00694   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = <a class="code" href="namespacetlm.html#3d28c3714f7375334465f92755ed3e36">establish_context</a>(txn);
<a name="l00695"></a>00695   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d6c5b6fb7e74f050d115825408688dab">from_f</a> = &amp;(tlm_from_hostendian_aligned&lt;DATAWORD&gt;);
<a name="l00696"></a>00696   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a> = sizeof_databus;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698   <span class="keywordtype">int</span> words_per_bus = sizeof_databus/<span class="keyword">sizeof</span>(DATAWORD);
<a name="l00699"></a>00699   <span class="keywordflow">if</span>(words_per_bus == 1) <span class="keywordflow">return</span>;
<a name="l00700"></a>00700   <span class="keywordtype">int</span> words = (txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>())/<span class="keyword">sizeof</span>(DATAWORD);
<a name="l00701"></a>00701 
<a name="l00702"></a>00702   DATAWORD *original_be = (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00703"></a>00703   DATAWORD *original_data = (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>());
<a name="l00704"></a>00704 
<a name="l00705"></a>00705   <span class="comment">// always allocate a new data buffer</span>
<a name="l00706"></a>00706   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#03a1359e212624b834b64ac4b36a82ba">set_data_ptr</a>(<a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>.<a class="code" href="classtlm_1_1tlm__buffer__pool.html#4f26fed0eba7796a462b4e13258488cc">get_a_buffer</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>()));
<a name="l00707"></a>00707 
<a name="l00708"></a>00708   <span class="keywordflow">if</span>(original_be == 0) {
<a name="l00709"></a>00709     <span class="comment">// no byte enables</span>
<a name="l00710"></a>00710     <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#234bd44edb3ccb706b7ba030c3a2200d">is_write</a>()) {
<a name="l00711"></a>00711       <span class="comment">// WR no byte enables.  Copy data</span>
<a name="l00712"></a>00712       loop_aligned2&lt;DATAWORD, &amp;copy_d2&lt;DATAWORD&gt; &gt;(original_data, 0,
<a name="l00713"></a>00713         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>()), 0,
<a name="l00714"></a>00714         words, words_per_bus);
<a name="l00715"></a>00715     } <span class="keywordflow">else</span> {
<a name="l00716"></a>00716       <span class="comment">// RD no byte enables.  Save original data pointer</span>
<a name="l00717"></a>00717       tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a> = (<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)original_data;
<a name="l00718"></a>00718     }
<a name="l00719"></a>00719   } <span class="keywordflow">else</span> {
<a name="l00720"></a>00720     <span class="comment">// byte enables present</span>
<a name="l00721"></a>00721     <span class="comment">// allocate a new buffer for them</span>
<a name="l00722"></a>00722     txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#ef1f7d2a2d743aaa304a85d361e880db">set_byte_enable_ptr</a>(
<a name="l00723"></a>00723       <a class="code" href="namespacetlm.html#ccf7166f46efc3b41300b9c33bb94f27">local_buffer_pool</a>.<a class="code" href="classtlm_1_1tlm__buffer__pool.html#4f26fed0eba7796a462b4e13258488cc">get_a_buffer</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>()));
<a name="l00724"></a>00724     txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#465e5b08194660aa0b66d4e8219fa887">set_byte_enable_length</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>());
<a name="l00725"></a>00725 
<a name="l00726"></a>00726     <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#234bd44edb3ccb706b7ba030c3a2200d">is_write</a>()) {
<a name="l00727"></a>00727       <span class="comment">// WR with byte enables.  Copy data and BEs</span>
<a name="l00728"></a>00728       loop_aligned2&lt;DATAWORD, &amp;copy_db2&lt;DATAWORD&gt; &gt;(original_data, original_be,
<a name="l00729"></a>00729         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>()),
<a name="l00730"></a>00730         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>()), words, words_per_bus);
<a name="l00731"></a>00731     } <span class="keywordflow">else</span> {
<a name="l00732"></a>00732       <span class="comment">// RD with byte enables.  Save original data pointer</span>
<a name="l00733"></a>00733       tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a> = (<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)original_data;
<a name="l00734"></a>00734       <span class="comment">// Copy byte enables to new buffer</span>
<a name="l00735"></a>00735       loop_aligned2&lt;DATAWORD, &amp;copy_d2&lt;DATAWORD&gt; &gt;(original_be, 0,
<a name="l00736"></a>00736         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>()), 0,
<a name="l00737"></a>00737         words, words_per_bus);
<a name="l00738"></a>00738     }
<a name="l00739"></a>00739   }
<a name="l00740"></a>00740 }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742 
<a name="l00743"></a>00743 
<a name="l00745"></a>00745 <span class="comment">// function set (3): Response</span>
<a name="l00746"></a>00746 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00747"></a><a class="code" href="namespacetlm.html#2c263fbf6cf9755d9f6eeca09dd23838">00747</a> <a class="code" href="namespacetlm.html#2c263fbf6cf9755d9f6eeca09dd23838">tlm_from_hostendian_single</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00748"></a>00748   <span class="comment">// nothing needs to be done here</span>
<a name="l00749"></a>00749 }
<a name="l00750"></a>00750 
<a name="l00751"></a>00751 
<a name="l00753"></a>00753 <span class="comment">// function set (3): Request</span>
<a name="l00754"></a>00754 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00755"></a><a class="code" href="namespacetlm.html#a0b3eb97d390a24dd271eea549885fdf">00755</a> <a class="code" href="namespacetlm.html#a0b3eb97d390a24dd271eea549885fdf">tlm_to_hostendian_single</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00756"></a>00756   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = <a class="code" href="namespacetlm.html#3d28c3714f7375334465f92755ed3e36">establish_context</a>(txn);
<a name="l00757"></a>00757   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d6c5b6fb7e74f050d115825408688dab">from_f</a> = &amp;(tlm_from_hostendian_single&lt;DATAWORD&gt;);
<a name="l00758"></a>00758   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a> = sizeof_databus;
<a name="l00759"></a>00759 
<a name="l00760"></a>00760   <span class="comment">// only need to change the address, always safe to work in-place</span>
<a name="l00761"></a>00761   sc_dt::uint64 mask = sizeof_databus-1;
<a name="l00762"></a>00762   sc_dt::uint64 a = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>();
<a name="l00763"></a>00763   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#486d7746584d058f148f6b3d6aab55c4">set_address</a>((a &amp; ~mask) |
<a name="l00764"></a>00764     (sizeof_databus - (a &amp; mask) - <span class="keyword">sizeof</span>(DATAWORD)));
<a name="l00765"></a>00765 }
<a name="l00766"></a>00766 
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 
<a name="l00770"></a>00770 <span class="comment">// helper function which works for all responses</span>
<a name="l00771"></a><a class="code" href="namespacetlm.html#7089b671b64863a5d1f59b8b5c9f648f">00771</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#7089b671b64863a5d1f59b8b5c9f648f">tlm_from_hostendian</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn) {
<a name="l00772"></a>00772   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#57e1f088841057cd1c2717701c240396">get_extension</a>&lt;<a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a>&gt;();
<a name="l00773"></a>00773   (*(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d6c5b6fb7e74f050d115825408688dab">from_f</a>))(txn, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a>);
<a name="l00774"></a>00774 }
<a name="l00775"></a>00775 
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 <span class="preprocessor">#ifndef TLM_END_CONV_DONT_UNDEF_UCHAR</span>
<a name="l00778"></a>00778 <span class="preprocessor"></span><span class="preprocessor">#undef uchar</span>
<a name="l00779"></a>00779 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00780"></a>00780 <span class="preprocessor"></span>
<a name="l00781"></a>00781 }  <span class="comment">// namespace tlm</span>
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 <span class="preprocessor">#endif  // multiple-inclusion protection</span>
<a name="l00785"></a>00785 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Thu Jun 5 17:43:03 2008 for TLM 2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
